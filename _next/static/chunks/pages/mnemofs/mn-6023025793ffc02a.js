(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[966],{6917:function(e,n,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/mnemofs/mn",function(){return t(9899)}])},9899:function(e,n,t){"use strict";t.r(n),t.d(n,{__toc:function(){return c},home:function(){return m},next:function(){return d},prev:function(){return h}});var o=t(2676),a=t(109),s=t(9394),r=t(5904);t(1705);var i=t(9100),l=t(353);let h="/mnemofs/journal",m="/",d="/mnemofs/ba",c=[{depth:2,value:"Journal Flush",id:"journal-flush"},{depth:2,value:"Conclusion",id:"conclusion"}];function u(e){let n=Object.assign({h1:"h1",p:"p",code:"code",h2:"h2",hr:"hr"},(0,i.a)(),e.components);return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h1,{children:"Mnemofs's Master Node"}),"\n",(0,o.jsx)(n.p,{children:"The master node in mnemofs is the entity that can be used to get the location of the root of the file system."}),"\n",(0,o.jsxs)(n.p,{children:["When the journal is flushed (or, rather, the first ",(0,o.jsx)(n.code,{children:"n"})," blocks are flushed), then all of the changes in the journal are applied to the entire file system in a true CoW way, and this finally cascades to the root of the file system, till the root is updated."]}),"\n",(0,o.jsx)(n.p,{children:'At this state, both the old data and the new data exist simultaneously, and the new location of the root is recorded in a new master node, and written to the flash. Once the new master node is written to the flash, only the the entire file system\'s "base state" gets updated, and now there is no risk of losing changes or leaving the device in an unrecoverable state (at least, till new updates come in). The block allocator ensures that both the data exist together, and that old pages are not erased, till the new master node is not written, which can allow for rollback of changes.'}),"\n",(0,o.jsx)(n.p,{children:'The master blocks are duplicates of each other, and contain multiple instances of the master node. Master node takes no more than a single page, and contains information about the root, in a way similar to a parent directory. The master blocks contain various "revisions" (or instances) of the master blocks. It\'s important to note that only the latest master block is a "valid" master block. This means that all older master blocks do not point to a valid file system.'}),"\n",(0,o.jsx)(n.h2,{id:"journal-flush",children:"Journal Flush"}),"\n",(0,o.jsxs)(n.p,{children:["The first ",(0,o.jsx)(n.code,{children:"n"})," blocks of the journal will be erased much more often than the master blocks, due to the design of the file system. This means that the journal needs to move for every time it's flushed. However, not all of the journal needs to follow this. The master blocks will move only when they are full, which happens after each integral number of journal flushes. Thus, there are some times when the journal moves alone, while at others, the journal moves along with the msater blocks."]}),"\n",(0,o.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsx)(n.p,{children:"Here you saw how the journal of mnemofs works. Now, moving on to the block allocator."}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsxs)(l.oy,{children:[(0,o.jsx)(l.Zb,{icon:"❰ ",title:"Mnemofs Journal",href:h}),(0,o.jsx)(l.Zb,{icon:"❱ ",title:"Mnemofs Block Allocator",href:d})]}),"\n",(0,o.jsx)("br",{}),"\n",(0,o.jsx)(l.Zb,{icon:"⌂ ",title:"Home",href:m})]})}let f={MDXContent:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.a)(),e.components);return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(u,{...e})}):u(e)},pageOpts:{filePath:"pages/mnemofs/mn.mdx",route:"/mnemofs/mn",timestamp:1720453792e3,pageMap:[{kind:"MdxPage",name:"coming_soon",route:"/coming_soon"},{kind:"MdxPage",name:"index",route:"/"},{kind:"Folder",name:"mnemofs",route:"/mnemofs",children:[{kind:"MdxPage",name:"ba",route:"/mnemofs/ba"},{kind:"MdxPage",name:"intro_p1",route:"/mnemofs/intro_p1"},{kind:"MdxPage",name:"intro_p2",route:"/mnemofs/intro_p2"},{kind:"MdxPage",name:"intro_p3",route:"/mnemofs/intro_p3"},{kind:"MdxPage",name:"journal",route:"/mnemofs/journal"},{kind:"MdxPage",name:"lru",route:"/mnemofs/lru"},{kind:"MdxPage",name:"mideval",route:"/mnemofs/mideval"},{kind:"MdxPage",name:"mn",route:"/mnemofs/mn"},{kind:"MdxPage",name:"mnemofs",route:"/mnemofs/mnemofs"},{kind:"Meta",data:{ba:"Ba",intro_p1:"Intro P1",intro_p2:"Intro P2",intro_p3:"Intro P3",journal:"Journal",lru:"Lru",mideval:"Mideval",mn:"Mn",mnemofs:"Mnemofs"}}]},{kind:"Meta",data:{coming_soon:"Coming Soon",index:"Index"}}],flexsearch:{codeblocks:!0},title:"Mnemofs's Master Node",headings:c},pageNextRoute:"/mnemofs/mn",nextraLayout:s.ZP,themeConfig:r.Z};n.default=(0,a.j)(f)},5904:function(e,n,t){"use strict";var o=t(2676);n.Z={footer:(0,o.jsx)("p",{children:"MIT 2024 \xa9 resyfer."}),head:e=>{let{title:n,meta:t}=e;return(0,o.jsxs)(o.Fragment,{children:[t.description&&(0,o.jsx)("meta",{name:"description",content:t.description}),t.tag&&(0,o.jsx)("meta",{name:"keywords",content:t.tag}),t.author&&(0,o.jsx)("meta",{name:"author",content:t.author}),(0,o.jsx)("script",{async:!0,src:"https://www.googletagmanager.com/gtag/js?id=G-HFNGDFK1PN"}),(0,o.jsx)("script",{children:"\n        window.dataLayer = window.dataLayer || [];\n        function gtag(){dataLayer.push(arguments);}\n        gtag('js', new Date());\n\n        gtag('config', 'G-HFNGDFK1PN');\n        "})]})},postFooter:!1}}},function(e){e.O(0,[253,888,774,179],function(){return e(e.s=6917)}),_N_E=e.O()}]);