{"/coming_soon":{"title":"Coming Soon","data":{}},"/":{"title":"resyfer's Dev Blog","data":{"":"Hi, I am Saurav Pal, and I code under the name resyfer. Here's a blog to share my two cents on stuff.","about-me#About Me":"I'm an enthusiastic developer who's open to learning anything and everything related to operating systems, embedded systems, and networking, and I like open source.I am a Google Summer of Code 2024 (GSoC '24') contributor to Apache organization in which I am working on designing and implementing mnemofs, which is a filesystem for NAND Flashes for the Apache NuttX Real Time Operating System (RTOS).I'm also currently an upcoming Associate Software Engineer at Oracle.I was also a GSoC '23 contributor to PostgreSQL as well, working on improving PostgreSQL version support for pgexporter.I am currently a fresh graduate from the National Institute of Technology, Silchar, which is one of the Institutions of National Importance in India, in which I was pursing a Bachelor of Technology (B. Tech.) in Computer Science and Engineering (CSE) for 4 years (from Nov 2020 - May 2024).","blogs#Blogs":"Here are my blogs.\nmnemofs\nIntroduction Part 1"}},"/mnemofs/intro_p1":{"title":"Introduction Part I | mnemofs","data":{"":"So, designing and implementing a file system...a daunting task, and very overwhelming. BUUUT here's me delving into the concepts to the best of my knowledge. Grab a drink or a popcorn as it's gonna take a while.","storage#Non-Volatile Storage":"Non-volatile storages like hard disk drives (HDDs), Solid State Drives (SSDs), Compact Disks (CDs), Pen Drives, NAND Flash Devices, etc. are basically entire arrays that you can use to store anything.What makes it different from arrays in your Random Access Memory (RAM)? Many things. But most important of them is that it is non-volatile. This means that if something is stored in it, it will stay on it even if power is no longer supplied to the device. As an additional bonus, as far as storage mediums that exist till date go, if you store even a byte at a location, say, x, then it will be at x unless deleted explicitly (or some unexpected event can modify your storage, but more about it later!).Another difference is that, usually with an operating system (OS) running on your device, in RAM, you can not really specify where you want a data to be stored in terms of absolute postition in the device. If you try to write, say a byte, at position x, it needs to be within the allowed locations by the kernel of the OS. Without getting too much into it here as it is out of scope, if you do not write within the confines specified, you get hit with bad karma in the form of Segmentation fault (core dumped).\nThere might be people trying to say you can not do that to a non-volatile device running on an OS as a user either blah blah, while others will counter it with their own written kernel module to do it but those are technicalities, and it will only result in confusion.\nThus, having established that they are different, we'll be calling volatile memory (primary memory) like RAM as memory, and non-volatile memory (or secondary memory) like HDDs, etc. as storage. Storage is slower than memory, but it is also cheaper per byte. Adding the advantage of non-volatile nature of storage shows you why it's such a popular medium of storing things.In of itself, storage seems like a very good thing...but it is a fox in sheep's clothing. It can go horribly wrong if not used properly. In fact, the false sense of security of having your data persist can make the shock even bigger if you can not access your data for whatever reason due to improper use.","fs#File Systems":"","fs-need#Why are they needed?":"A thing to note is that a user would be better off printing out everything compared to managing the data on a storage device manually. Why? Here's an example to help you grasp that situation.Let's say there are 16 Bytes (16B) of storage on a device, and you want to store 4 pieces of information, each of 4B. If we split it into blocks of 1B each, we can give 4 consecutive blocks to each piece, and write it down somewhere, say on a paper, on which piece is where. Say, after sometime, 4th piece is no longer required, but your 2nd piece also suddenly needs 3B instead of the original 4. So you will clear the 4th piece's data from the device, and clear the last block given to your 2nd piece, so it only has 3B. Now the 8th, 13th, 14th, 15th, and 16th blocks are clear of data. Now, if another new piece (5th piece) wants 2B of storage, you give 8th and 13th place to it, and so on and on.\nIf you got confused while reading the example, that just proves my point.\nThis is very confusing to think and more importantly, difficult to remember. And here we are, barely talking about 16 B of information space and 4 pieces of information. Reality is harsher. We need to store SOOOOO many things. Your high definition (HD) photos, your movies, your applications, your games, and so on. A normal user just wants to store things without pain. The above mentioned method is very much an alternative definition of pain.\nPain always exists.\nIf you can't feel it,\nit's probably being shouldered\nby someone else.\n- Me, 2k24\nSo, some developers take that pain away from you onto their shoulders, and bring you file systems which are programs that manage your storage without you having to think about them too much.","file-system-components#File System components":"File systems have a lot of components. Like a car, some of them are very much visible to a user and they are aware of their presence, while the others are kept under-the-hood. These components are called file system objects (fs objects).Also like the parts of a car, these fs objects have different names depending on whom you ask. We'll stick to Linux (/ Unix / POSIX) terminology here, but at the end it is just a name.We'll go through some of the very common ones below, while we keep others for later exploration as we delve deeper into flie systems.","file#File":"In a traditional sense, any collective piece of information that is part of one entity is one file. Like, a photo. One entire entity. It is a very loose definition. What if you cropped an image into 4 pieces and kept them separately? You do you, no judgement.Take it like a collection of information that you want to be kept together, such that programs can work on the entire thing together. An image viewer can show you an entire image in one go if you keep all of it together. A video player can play your entire movie in one go if kept in one piece. And so on.They are analogous to a single paper, or multiple papers that are kept together in thing called a file (usually seen in the old photos of offices from a time close to the ice age) as they belong to the same topic.","directory#Folders / Directories / Drawers":"Again, work terminology. They are called many different things. We'll stick to directories, as Linux calls it. They are just a group of files and/or other directories as well. Why are they even needed? Multiple reasons. Right answer is that it depends on the user. But, here are some of the common reasons:\nOrganization. We like to be viewed as organized intellectual beings. So we organized multiple files in a hierarchical system so that topics become more specific the further down in the hierarchy you go.\nSearching. Suppose you have 500 files in your view. If you want to look for a specific file, you need to go through, in the worst case, all of them. If organized, the search may be way faster as you would know which directory, and the same inside it, and so on.\netc.","symlinks#Symbolic Links (symlinks) / Shortcuts":"Suppose you have a file in a directory that is very deep in a hierarchical system of directories. But suppose there's this folder called \"My Desktop\" in which, if files are kept, will be shown on...your Desktop (ðŸ¤¯). Now, keeping everything on your Desktop would not make sense, and that file is happy where it is. And you're mostly happy with where it is as well. But you need it on your Desktop as well.Well, copy it, duh! But updating one does not update the other. Thus, came symlinks. They are a type of file which points to the location of another file. There are two types of symlinks, but technicalities.Symlinks might not have universal support as they might not be considered essential for the target audience of the OS, but most major general purpose OSes do support them.","inodes#Inodes":"Files usually have two types of data associated with them. Their content, and their metadata. Their content is what we usually refer to as files. Their metadata usually refers to the information about the file. If you go back to the work terminology, it might be analogous to the information written on the cover of the physical file.These contain information like the file's name, their owner (who created it, or who owns it, etc. in a multi-user environment), their creation date, their last modification date, their last access date, their size, and so on. These are stored as another fs object called an inode.Inodes are very much optional too, and it depends on the file system on how they want to manage the metadata.","conclusion#Conclusion":"So, we glanced over the basic knowledge required to start learning about file systems. The fun and games end here, and in Part II, it's time to dive into the depths of file systems, and file system development."}},"/mnemofs/intro_p2":{"title":"Introduction Part II | mnemofs","data":{"":"We'll dive into a incremental explanation of various concepts involved with file systems and operating systems. It dives into a lot of \"suppose\" and \"what ifs\" to try and get you the sense of the problems that lurk in plain sight. Only by recognizing the existence of these problems can people think about trying to solve them.\nSolutions exist\nonly after problems\nare identified.\n- Me, 2k24","fs-os#File Systems and Operating Systems":"If you develop your own OS, and if you develop your own file system (FS), and if you only want your own FS in your OS, then you can develop them pretty much however you like it. Your OS can change to suit your FS needs, or vice versa. No need to be considerate of users or other developers who differ in opinions. Make your own OS-FS pair if you are so much better! No need to be the most efficient! If it gets the job done, it is good enough!This \"true power\" is what probably was felt by the developers of DOS decades ago.The world has changed since then. For the better or worse, it has become too complex and too demanding for one solution to be efficient or even sufficient for all needs out there. If you're a FS developer, not only is there someone out there who can do it better, you need to tailor your FS to support a very specific subset of storage devices / technologies to be efficient in that subset of storage technologies.","vfs#Virtual File Systems (VFS)":"","vfs-why#Why?":"Let's say I am an OS developer, and my under-development OS has this file system that I have named abcdfs, and I have to make my OS interact with the FS using the methods that my FS exposes like:\nint abcdfs_open_file_from_path(char *path);\nint abcdfs_close(char *path);\nint (char *path);\nIn such a world, if I am developing my own OS-FS pair, my FS doesn't really have a hard boundary on what it can or can not do. It can try and access the internet, or send an email, run your game, etc.Can you see the problem? The implementation of the communication between an OS and FS would change depending on the FS. No standardization, a free but chaotic mess.Also, early on, in the 1980s, with the rise of a lot of FSs that seemed to be more or less similar to each other, there was a rise of an opinion that an OS should allow users to choose their preferred file system.A nightmare if you combine the problems.So the OS developers put some restrictions on the FS developers in the form of standardization. Wherever there is standardization, there are restrictions, but also flexibility in choosing solutions.","vfs-what#What?":"A Virtual File System (vfs) is basically a simple interface that the OS demands an FS to implement. This allows the OS to use multiple file systems at once, and execute the necessary one.For example, if an OS defines its interface to be like this:\nstruct vfs_ops {\n    char (*open)(char *),\n    char (*close)(char *),\n};\nthen it means that it wants every file system to have one open, and one close functions at least. The file systems can then expose it like:\nstruct vfs_ops abcdfs_vfs_ops = {\n    .open = abcdfs_open_file_from_path,\n    .close = abcdfs_close,\n};\nThis interface is what the OS will use to interace with the file system. If a user wants to open a file, then the OS can expose a system call like int open(char *path) for the user. The internal implementation can be over-simplified to this:\nint open(char *path)\n{\n    // headache stuff\n    struct vfs_ops ops = get_vfs_ops_from_path(path); // ops == abcdfs_vfs_ops\n    ops->open(path);\n    // even more headache stuff\n}\nThis has some obvious advantage:\nThe user does not need to care about the underlying FS being used.\nThe FS developer does not need to develop their own OS.\nThe FS developer just needs to modify their exsting FS to include the interface of the OS they want to run their FS on.","drivers-and-operating-systems#Drivers and Operating Systems":"Without diving into too much details, a lot of OSes also have an interface similar to a VFS for device drivers, which includes drivers for storage devices.Now the FS developers do not have to explicitly support a very specific storage device from a very specific manufacturers, but can become more generalized. Instead of making a FS that supports only Samsung 1TiB SSDs, I can move on to making an FS that instead, say, supports only SSDs, leaving the implementation details to the drivers provided by the manufactureres.Again, redistribution of pain.So in a way similar to the communication between OS and FS, the FS can now interact with the storage device through the OS using their respective interfaces like:\nint xfs_open_from_path(char *path) {\n    // code\n    struct device dev = get_device_from_path(path);\n    if(device_type(dev) != STORAGE_DEVICE) {\n        return -EINVAL;\n    }\n    struct storage_driver_ops ops = get_storage_driver_ops_from_device(dev);\n    ops->read_at_offset_in_bytes(offset);\n    // more code\n}","entire-flow#Entire Flow":"Let's go over the entire flow.A storage device is connected to your computer or machine, and the CPU can communicate with it using the driver it provides (not going into too many details of this part here as it deals with hardware I/O).Your OS will have that one FS it supports internally. It is upto the OS developer, and can be anything...rootfs, fat32, etc. This maintains a global hierarchical system from the root /. Due to the whole \"everything in Linux is a file\" thing, your device may be visible as a device in with a path like /dev/my_device. Again, it exploits the whole VFS-is-just-an-interface thing. As long as it is follows the interface, it can still do pretty much anything on your OS given enough permissions. A free, but not chaotic mess ðŸ¥³.If you want to use this device with a file system, you need to mount it. So, this storage is then mounted at a certain location in your computer's location, say, /hi. This process involves mentioning the file system that you want to mount this device with, say abcdfs. This creates a directory /hi which will now serve as the root for this storage device. The metadata about the mount process is stored by the OS (where it is stored is implementation dependent).Now, when a user wants to, say, create a file /hi/my_file3, they will call the required system call (syscall) that the OS provides for creating a file at a given path. Inside this syscall, the OS will try to create a file /my_file3 to the storage device mounted at /hi. It will get the VFS operations of the file system that was used to mount the device at /hi, and use the create method exposed by that file system to create that file.The create method exposed by the file system might itself use a write function exposed by the driver of the storage device through the mount point. A mount point contains information of the file system and the device, and thus, both the device's driver operations, and file system's operations can be used through the mount point.This is a very simplified and generalized way in which OS, FS and devices interact with each other.","conclusion#Conclusion":"Here we learnt how FS interacts with the OS, and in Part III, we'll dive into FS and the various solutions that have emerged through the decades to an apparently \"simple problem\"."}}}