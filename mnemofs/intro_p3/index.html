<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>Introduction Part III | mnemofs</title><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-HFNGDFK1PN"></script><script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag(&#x27;js&#x27;, new Date());

        gtag(&#x27;config&#x27;, &#x27;G-HFNGDFK1PN&#x27;);
        </script><meta name="next-head-count" content="5"/><link rel="preload" href="/blogs/_next/static/css/a0de50ea0cc40a66.css" as="style"/><link rel="stylesheet" href="/blogs/_next/static/css/a0de50ea0cc40a66.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/blogs/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/blogs/_next/static/chunks/webpack-b7c95b972d7a52a1.js" defer=""></script><script src="/blogs/_next/static/chunks/framework-a85322f027b40e20.js" defer=""></script><script src="/blogs/_next/static/chunks/main-25a9149b204a716f.js" defer=""></script><script src="/blogs/_next/static/chunks/pages/_app-ae69650375182de2.js" defer=""></script><script src="/blogs/_next/static/chunks/253-8360a865f593540b.js" defer=""></script><script src="/blogs/_next/static/chunks/pages/mnemofs/intro_p3-4b7ced8c3ff672b4.js" defer=""></script><script src="/blogs/_next/static/1JMPumN35sRKB9wf_vaUv/_buildManifest.js" defer=""></script><script src="/blogs/_next/static/1JMPumN35sRKB9wf_vaUv/_ssgManifest.js" defer=""></script></head><body><div id="__next"><script>!function(){try{var d=document.documentElement,c=d.classList;c.remove('light','dark');var e=localStorage.getItem('theme');if('system'===e||(!e&&true)){var t='(prefers-color-scheme: dark)',m=window.matchMedia(t);if(m.media!==t||m.matches){d.style.colorScheme = 'dark';c.add('dark')}else{d.style.colorScheme = 'light';c.add('light')}}else if(e){c.add(e|| '')}if(e==='light'||e==='dark')d.style.colorScheme=e}catch(e){}}()</script><article class="nx-container nx-prose max-md:nx-prose-sm dark:nx-prose-dark" dir="ltr"><h1>Introduction Part III | mnemofs</h1><div class="nx-mb-8 nx-flex nx-gap-3 nx-items-center"><div class="nx-grow dark:nx-text-gray-400 nx-text-gray-600"><div class="nx-not-prose nx-flex nx-flex-wrap nx-items-center nx-gap-1"></div></div><div class="nx-flex nx-items-center nx-gap-3 print:nx-hidden"></div></div><div style="text-align:justify"><p>File systems have existed for almost as long as storage mediums have, which is to say, decades. File systems started out very simple. As the needs of users increased, as operating systems evolved, and as the quirks of storage mediums increased in exchange for providing maximum efficiency under very specific conditions, file systems had to adapt, and they generally became more complex but more specific.</p><p>The rest of this blog takes heavy inspiration from <a href="https://github.com/littlefs-project/littlefs/blob/master/DESIGN.md" target="_blank" rel="noreferrer">littlefs&#x27;s design document<span class="nx-sr-only nx-select-none"> (opens in a new tab)</span></a>, which is a file sytem that deserves to be put in an art gallery.</p><h2 class="nx-not-prose subheading-h2">Types of File Systems<a href="#types-of-file-systems" id="types-of-file-systems" class="subheading-anchor" aria-label="Permalink for this section"></a></h2><p>There have been various file systems with their various quirks, but they can be generally divided into four types.</p><h3 class="nx-not-prose subheading-h3">Block Based File Systems<a href="#block-based-file-systems" id="block-based-file-systems" class="subheading-anchor" aria-label="Permalink for this section"></a></h3><p>These are file systems that represent the used storage space in the form of a tree. They are also the oldest types of file systems out there.</p><p>They divide the storage into various blocks in which files are stored. Any updates to the files are done in place. Let&#x27;s say block <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">x</code> contains my file, and if I want to update the file, the same block is rewritten with the new updated file&#x27;s content.</p><p>Can you see the problem? Suppose my block is 256 B in size, and that contains a file of size 256 B as well. Say some random bytes, say <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">13</code>th, <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">19</code>th, <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">100</code>th, and <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">105</code>th bytes, are to be updated to new values by your computer. Let&#x27;s say the writes can be done at a maximum rate of 1 B at a time. And to add to this, let&#x27;s say our luck is very bad, and after it has updated the <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">19</code>th block, there is a power failure, and the write operation stops, and so does your computer. Now there is no information on what changes are remaining, or what has already been written.</p><p>You get a situation where some of the file is updated while the rest isn&#x27;t.</p><p>Nightmare.</p><p>This is called non-atomicity, or non-resiliency. They are not resilient to power losses as they are not atomic. If an operation is atomic, it means that if it is interrupted in between executions, any changes it makes will be reverted back to the pre-execution state.</p><p>Some examples of this type of file system are <a href="https://en.wikipedia.org/wiki/File_Allocation_Table" target="_blank" rel="noreferrer">FAT<span class="nx-sr-only nx-select-none"> (opens in a new tab)</span></a> and <a href="https://en.wikipedia.org/wiki/Ext2" target="_blank" rel="noreferrer">ext2<span class="nx-sr-only nx-select-none"> (opens in a new tab)</span></a>.</p><p>Without modifications (as seen later), these file systems do not stand up to modern needs for atomicity. You need your file to be updated, but even the previous state is better than a possibly garbled mess.</p><p>While this might not seem to be much of an issue for text files, for files encoded using encoding algorithms, this is quite a hell. Depending on the encoding algorithm, it has a very likely outcome of the entire file being corrupted because the decoder can no longer decode the file and hence will give that error.</p><p>Another disadvantage of such file systems can be that if there is a file that is updated very often compared to others, the location on the storage device, where the file is located, will be used much more than other areas of the device, leading to uneven wear distribution. This may end up causing that particular area of storage device to die before the others.</p><p>An advantage of such file systems is speed. Due to their simple design, they are very fast.</p><h3 class="nx-not-prose subheading-h3">Log Based File Systems / Log Structured File Systems<a href="#log-based-file-systems--log-structured-file-systems" id="log-based-file-systems--log-structured-file-systems" class="subheading-anchor" aria-label="Permalink for this section"></a></h3><p>On the other extreme, there are log based file systems that take atomicity <strong><em>very</em></strong> seriously. Instead of treating the entire storage as an array, they treat it similar to a queue.</p><p>Any change has a corresponding entry, which is stored in the storage device in a first-in, first-out (FIFO) manner, i.e. each new entry is stored after the end of the last stored entry. To recreate a file, all that is needed is to iterate over all of the entries in a queue. Usually each entry has a checksum of the entry suffixed to it.</p><p>The checksum is usually a value obtained by hashing an entire log. While reading an entry or log, if the stored checksum does not match the calculated checksum of the log, the log is discarded, as it means that the log was not written properly. If you assume your file system is bug-free, this usually narrows the culprits to power loss.</p><p>It might seem really great initially, but see the problem? It is <strong>very</strong> slow. Suppose each read (one bytes) from the device is one instruction (that&#x27;s quite generous as it&#x27;s 100x slower than reading a value from RAM! ), and you have a 4 GiB device. This means 4294967296 B, so that many instructions are needed to traverse the entire storage. Ignore any calculations we do with the data; this would take about 1.38 seconds if an Intel i5 10th generation was running on its base frequency of 2.9 GHz (assuming no optimisations). As mentioned, calling it one instruction per read is being generous. This means that every time you open a file, you need to wait 1.38 seconds at the very least. And moreover, the processor used for this calculation is quite a beast in itself.</p><p>CPUs in embedded systems are slower. STM32F401CCU6 has a CPU with 84 MHz frequency. So, the same operation under the same assumptions would take it 48 seconds. Do remember, this is just 4 GB of storage capacity.</p><p>Nightmare, but in another direction.</p><p>An advantage of such file systems is of course, absolute atomicity. But another advantage is wear leveling. Since entries are added in a FIFO manner, it will ensure that any pair of blocks has a maximum wear level difference of 1. The wear levels of the blocks of storage would always look like <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">[x+1, x+1,..., x+1, x+1, x, x, x,..., x, x]</code>, where the last <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">x+1</code> wear is the location of the last entry.</p><p>A disadvantage, apart from being slow, is what happens if the storage becomes full? Changes might be infinite depending on the user, and so will the entries that represent these changes. However, space is not infinite or file system development would not have been so difficult.</p><p>File systems of this type include <a href="https://en.wikipedia.org/wiki/JFFS" target="_blank" rel="noreferrer">JFFS<span class="nx-sr-only nx-select-none"> (opens in a new tab)</span></a>/<a href="https://en.wikipedia.org/wiki/JFFS2" target="_blank" rel="noreferrer">JFFS2<span class="nx-sr-only nx-select-none"> (opens in a new tab)</span></a>, <a href="https://en.wikipedia.org/wiki/YAFFS" target="_blank" rel="noreferrer">YAFFS<span class="nx-sr-only nx-select-none"> (opens in a new tab)</span></a>, or <a href="https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/storage/spiffs.html" target="_blank" rel="noreferrer">SPIFFS<span class="nx-sr-only nx-select-none"> (opens in a new tab)</span></a>.</p><h3 class="nx-not-prose subheading-h3">Journalling File Systems<a href="#journalling-file-systems" id="journalling-file-systems" class="subheading-anchor" aria-label="Permalink for this section"></a></h3><p>The very weird thing is that both of the above types of file systems have mutually exclusive advantages and disadvantages. So naturally, a middle ground approach would either benefit from both, or none.</p><p>We create a block-based file system, but we also reserve a certain place on the device for the FIFO queue to store logs. We call this FIFO queue the journal or bounded log. Best of both worlds. The block file system contains a sort of &quot;base&quot; state, and further changes to it are stored as entries or logs in the journal.</p><p>To get the updated version of the file, all the FS has to do is take the &quot;base&quot; state and iterate over the journal, applying changes to it.</p><p>Independent of implementation, there is a very strong relationship between storage location and data due to the presence of the journal. This can cause an abnormal increase in the wear of the journal along with the disadvantage of increased wear for a frequently updated file in block based file systems. Another problem is that there are essentially two file systems running in parallel, and both code complexity and execution may increase.</p><p>Depending on the implementation, this may have some additional problems. The file system may decide to <em>commit</em> logs to the file system when the journal is full. This means that the &quot;base&quot; state needs to be updated, and thus, the journal is emptied. The changes may be committed one by one, but power loss during committing the journal may cause garbled data as well.</p><p>This is the most popular category of file systems, and this category includes Linux&#x27;s most popular file system <a href="https://en.wikipedia.org/wiki/Ext4" target="_blank" rel="noreferrer">ext4<span class="nx-sr-only nx-select-none"> (opens in a new tab)</span></a>, and Window&#x27;s <del>most popular</del> (actually you don&#x27;t have a choice, as far as daily files go) file system <a href="https://en.wikipedia.org/wiki/NTFS" target="_blank" rel="noreferrer">NTFS<span class="nx-sr-only nx-select-none"> (opens in a new tab)</span></a>.</p><h3 class="nx-not-prose subheading-h3">Copy On Write File Systems<a href="#copy-on-write-file-systems" id="copy-on-write-file-systems" class="subheading-anchor" aria-label="Permalink for this section"></a></h3><p>A file system category based on an entirely new way of dealing with this problem is Copy-On-Write (CoW) file systems.</p><p>What does CoW mean? You want to update a value? Copy the entire thing and write on that copy. It&#x27;s similar to how some developers program before learning about the existence of version control.</p><p>Suppose a block (I&#x27;ll give it a name <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">x</code>) is at a location <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">p</code>. If you want to update it, you will read the entire block in memory, update the necessary parts in memory, and write the updated block to a new location <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">q</code>.</p><p>This sounds simple, but it&#x27;s a bit more complicated than that when you dive into the nuances of it.</p><p>So, files and directories exist in all these types of file systems, which include CoW file systems. This means that there is a hierarchical ordering of files and directories. A directory is a collection of files, so under working CoW file system implementations, a directory has some information about the location of a file.</p><p>Let&#x27;s update our file! Let&#x27;s assume our file is just one block in size for simplicity. So our file got updated, and its location shifted from <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">p</code> to <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">q</code>. But the directory that contains our file still points to <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">p</code>!!! So, we need to update our directory! But now, the parent directory of this directory faces a similar problem. This continues to propagate upward until it reaches the root of the entire file system&#x27;s tree. The root has no parent, so updating it updates the tree. BUT, unless your root is confined to some specific places in the device, you would need to store where the root is located as well, and this update problem again continues until it finally reaches something that either has a single fixed location (in which case it doesn&#x27;t follow CoW as it would need to be updated without changing location) or it has multiple fixed locations, in which case the file system has to figure out which one of the locations contains the most recent update.</p><p>Yep...A lot of problems, and a lot of headache.</p><p>An advantage of CoW file systems is that there are two copies of the block. Old and updated. If the update was not successful, the old version would be used.</p><p>The wear leveling here depends on the block allocator, which is responsible for providing the location where an update should be stored. Thus, a good algorithm for the block allocator will give good and even wear (copium 🤞, but it&#x27;s <em>possible</em> to do this, unlike other challenges that arise due to the nature of the file system).</p><p>A disadvantage of CoW file systems is pretty obvious, as shown above. A simple update takes too many copies and writes due to updating all the FS objects in the file&#x27;s path.</p><p>Another disadvantage is that it takes up quite a lot of space to keep copies. If you don&#x27;t have enough space to update a file (which includes not just the file but ancestors as well), a CoW file system is a bad choice.</p><p><em><em>Another</em></em> disadvantage can be that CoW file systems require a garbage collector. So, additional memory usage, and processing time. The garbage collector needs to figure out which blocks (old copies) it can safely erase, and which are required in case there is a power failure in the near future. This is not a computationally cheap thing to do.</p><p>The amount of extra space used by old copies is determined by the aggressiveness of the garbage collector, but no garbage collector should erase copies of the FS objects in the path of a file until it is sure the entire file has been updated.</p><h2 class="nx-not-prose subheading-h2">Conclusion<a href="#conclusion" id="conclusion" class="subheading-anchor" aria-label="Permalink for this section"></a></h2><p>There are too many types of file systems, and there are too many problems. They try to solve some problem but end up creating another or solving it partially. Mnemofs is heavily inspired by littlefs, which itself tries to take the best of both CoW and journaling file systems and combine them with some ingenious problem solving.</p><p>We&#x27;ll look into mnemofs, and specifically, its LRU in the next part.</p></div>
<hr/>
<div class="nextra-cards nx-mt-4 nx-gap-4 nx-grid nx-not-prose" style="--rows:3"><a class="nextra-card nx-group nx-flex nx-flex-col nx-justify-start nx-overflow-hidden nx-rounded-lg nx-border nx-border-gray-200 nx-text-current nx-no-underline dark:nx-shadow-none hover:nx-shadow-gray-100 dark:hover:nx-shadow-none nx-shadow-gray-100 active:nx-shadow-sm active:nx-shadow-gray-200 nx-transition-all nx-duration-200 hover:nx-border-gray-300 nx-bg-transparent nx-shadow-sm dark:nx-border-neutral-800 hover:nx-bg-slate-50 hover:nx-shadow-md dark:hover:nx-border-neutral-700 dark:hover:nx-bg-neutral-900" href="/blogs/mnemofs/intro_p2/"><span class="nx-flex nx-font-semibold nx-items-start nx-gap-2 nx-p-4 nx-text-gray-700 hover:nx-text-gray-900 dark:nx-text-neutral-200 dark:hover:nx-text-neutral-50 nx-flex nx-items-center">❰ <!-- -->Part II</span></a><a class="nextra-card nx-group nx-flex nx-flex-col nx-justify-start nx-overflow-hidden nx-rounded-lg nx-border nx-border-gray-200 nx-text-current nx-no-underline dark:nx-shadow-none hover:nx-shadow-gray-100 dark:hover:nx-shadow-none nx-shadow-gray-100 active:nx-shadow-sm active:nx-shadow-gray-200 nx-transition-all nx-duration-200 hover:nx-border-gray-300 nx-bg-transparent nx-shadow-sm dark:nx-border-neutral-800 hover:nx-bg-slate-50 hover:nx-shadow-md dark:hover:nx-border-neutral-700 dark:hover:nx-bg-neutral-900" href="/blogs/mnemofs/lru/"><span class="nx-flex nx-font-semibold nx-items-start nx-gap-2 nx-p-4 nx-text-gray-700 hover:nx-text-gray-900 dark:nx-text-neutral-200 dark:hover:nx-text-neutral-50 nx-flex nx-items-center">❱ <!-- -->Mnemofs LRU</span></a></div>
<br/>
<a class="nextra-card nx-group nx-flex nx-flex-col nx-justify-start nx-overflow-hidden nx-rounded-lg nx-border nx-border-gray-200 nx-text-current nx-no-underline dark:nx-shadow-none hover:nx-shadow-gray-100 dark:hover:nx-shadow-none nx-shadow-gray-100 active:nx-shadow-sm active:nx-shadow-gray-200 nx-transition-all nx-duration-200 hover:nx-border-gray-300 nx-bg-transparent nx-shadow-sm dark:nx-border-neutral-800 hover:nx-bg-slate-50 hover:nx-shadow-md dark:hover:nx-border-neutral-700 dark:hover:nx-bg-neutral-900" href="/blogs/"><span class="nx-flex nx-font-semibold nx-items-start nx-gap-2 nx-p-4 nx-text-gray-700 hover:nx-text-gray-900 dark:nx-text-neutral-200 dark:hover:nx-text-neutral-50 nx-flex nx-items-center">⌂ <!-- -->Home</span></a><p>MIT 2024 © resyfer.</p></article></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{}},"page":"/mnemofs/intro_p3","query":{},"buildId":"1JMPumN35sRKB9wf_vaUv","assetPrefix":"/blogs","nextExport":true,"autoExport":true,"isFallback":false,"scriptLoader":[]}</script></body></html>