<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>Mnemofs Least Recently Used (LRU) Cache</title><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-HFNGDFK1PN"></script><script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag(&#x27;js&#x27;, new Date());

        gtag(&#x27;config&#x27;, &#x27;G-HFNGDFK1PN&#x27;);
        </script><meta name="next-head-count" content="5"/><link rel="preload" href="/blogs/_next/static/css/a0de50ea0cc40a66.css" as="style"/><link rel="stylesheet" href="/blogs/_next/static/css/a0de50ea0cc40a66.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/blogs/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/blogs/_next/static/chunks/webpack-b7c95b972d7a52a1.js" defer=""></script><script src="/blogs/_next/static/chunks/framework-a85322f027b40e20.js" defer=""></script><script src="/blogs/_next/static/chunks/main-25a9149b204a716f.js" defer=""></script><script src="/blogs/_next/static/chunks/pages/_app-ae69650375182de2.js" defer=""></script><script src="/blogs/_next/static/chunks/253-8360a865f593540b.js" defer=""></script><script src="/blogs/_next/static/chunks/pages/mnemofs/lru-de155b784443d2be.js" defer=""></script><script src="/blogs/_next/static/1Bm8E84dQAa3Fb_3ZJfyf/_buildManifest.js" defer=""></script><script src="/blogs/_next/static/1Bm8E84dQAa3Fb_3ZJfyf/_ssgManifest.js" defer=""></script></head><body><div id="__next"><script>!function(){try{var d=document.documentElement,c=d.classList;c.remove('light','dark');var e=localStorage.getItem('theme');if('system'===e||(!e&&true)){var t='(prefers-color-scheme: dark)',m=window.matchMedia(t);if(m.media!==t||m.matches){d.style.colorScheme = 'dark';c.add('dark')}else{d.style.colorScheme = 'light';c.add('light')}}else if(e){c.add(e|| '')}if(e==='light'||e==='dark')d.style.colorScheme=e}catch(e){}}()</script><article class="nx-container nx-prose max-md:nx-prose-sm dark:nx-prose-dark" dir="ltr"><h1>Mnemofs Least Recently Used (LRU) Cache</h1><div class="nx-mb-8 nx-flex nx-gap-3 nx-items-center"><div class="nx-grow dark:nx-text-gray-400 nx-text-gray-600"><div class="nx-not-prose nx-flex nx-flex-wrap nx-items-center nx-gap-1"></div></div><div class="nx-flex nx-items-center nx-gap-3 print:nx-hidden"></div></div>
<p>Before diving into the LRU Cache, called LRU for short, we need to look into a data structure that every one seems to know, but with a slightly different flavor.</p>
<h2 class="nx-not-prose subheading-h2">Kernel Linked Lists<a href="#kernel-linked-lists" id="kernel-linked-lists" class="subheading-anchor" aria-label="Permalink for this section"></a></h2>
<p>Linux, and NuttX (among others) have this very special flavor of linked lists that seem to make it <em>just right</em>, called a kernel linked list, or simply, a kernel list. This is a circular doubly linked list which can be used to store <em>any</em> data type.</p>
<p>Below is a traditional circular doubly linked list.</p>
<p><img src="https://res.cloudinary.com/dbzi2yvvc/image/upload/v1720435118/mnemofs/Screenshot_20240708_160735_ivk5au.png" alt="dll"/></p>
<p>And the below is a kernel list.</p>
<p><img src="https://res.cloudinary.com/dbzi2yvvc/image/upload/v1720435871/mnemofs/Screenshot_20240708_162053_rjxu4o.png" alt="kl"/></p>
<p>The type <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">struct list_head</code> contains only pointers to other <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">struct list_head</code>. It doesn&#x27;t care about the structure it is part of. This can allow traversal, and conversion of any knd of structure
we want into a list. The question is, if we have a pointer, how do we get the original structure back?</p>
<p>The answer to that is pretty simple and brilliant. Pointer offsets. If your struct <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">struct my_struct</code> contains a member <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">struct list_head list</code>, then, let&#x27;s say, the offset of <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">list</code> from the start of the struct is <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">off</code>, then if we have an address <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">x</code> pointing to <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">list</code>, we can get its parent by just doing <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">x - off</code>. <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">off</code> will always remain constant for a given struct, and there are utilities provided to calculate them. In fact, the list utilities don&#x27;t require you to even have to think too much about how this works.</p>
<h2 class="nx-not-prose subheading-h2">LRU structure<a href="#lru-structure" id="lru-structure" class="subheading-anchor" aria-label="Permalink for this section"></a></h2>
<p>Back to the LRU. The LRU is in-memory, and its main purpose is to reduce the wear of your storage device. The way it does is by bunching some changes to the same file, and then writing them all
in one go.</p>
<p>The LRU is a kernel list of nodes. Each node represents a file or a directory. Each node contains deltas, which are basically the updates a user wants. The deltas are arranged in a kernel list for code reduction, however, they may use something as simple as a singly linked list. Deltas are of two types: either put <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">x</code> bytes at an offset <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">off</code> by replacing at maximum <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">x</code> bytes (less than <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">x</code> bytes at the end of a file), or delete <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">x</code> bytes from offset <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">off</code>.</p>
<p>When a new node is to be inserted, and if the LRU is full, the last node (tail of the list) is popped off, and all the deltas in it are written to the flash. This is called the flush operation. A flush operation may happen implicitly as explained, or explicitly in cases like where a file is closed.</p>
<p>When the deltas are written to the flash in an Copy-On-Write (CoW) manner, the new location and size is changed and the journal comes into play here. This need to be updated in the parent as well. Thus the parent goes through this same procedure for updates as well.</p>
<p>CoW file systems face a very common problem of cascading or bubbling up of updates. If a file is updated, its location changes. Thus the parent needs to be updated, and its location is changed as well, and so on this rises up the file system till the root is updated. However, unlike most CoW systems, the LRU does not let the updates bubble up into the file system immediately.</p>
<p>The LRU isn&#x27;t a <em>cache</em> in a strict sense, as the original data still needs to be read from the flash before applying the changes to the LRU. However, the main purpose it has is to batch updates together to reduce the number of times the file is updated in the flash. The size of the LRU is configurable during compile time, thus giving control over the RAM vs wear tradeoff. Also, if someone wants to apply the updates to the flash as soon as possible, then the LRU size should be kept to a minimum.</p>
<p>Power loss will cause all changes in the LRU to be lost. In fact, it&#x27;s the only bunch of updates that will be lost. The updates in the journal will remain, and the file system will be in a recoverable state at all times.</p>
<h2 class="nx-not-prose subheading-h2">Conclusion<a href="#conclusion" id="conclusion" class="subheading-anchor" aria-label="Permalink for this section"></a></h2>
<p>After the LRU, it&#x27;s turn to look at the journal in mnemofs.</p>
<hr/>
<div class="nextra-cards nx-mt-4 nx-gap-4 nx-grid nx-not-prose" style="--rows:3"><a class="nextra-card nx-group nx-flex nx-flex-col nx-justify-start nx-overflow-hidden nx-rounded-lg nx-border nx-border-gray-200 nx-text-current nx-no-underline dark:nx-shadow-none hover:nx-shadow-gray-100 dark:hover:nx-shadow-none nx-shadow-gray-100 active:nx-shadow-sm active:nx-shadow-gray-200 nx-transition-all nx-duration-200 hover:nx-border-gray-300 nx-bg-transparent nx-shadow-sm dark:nx-border-neutral-800 hover:nx-bg-slate-50 hover:nx-shadow-md dark:hover:nx-border-neutral-700 dark:hover:nx-bg-neutral-900" href="/blogs/mnemofs/mnemofs/"><span class="nx-flex nx-font-semibold nx-items-start nx-gap-2 nx-p-4 nx-text-gray-700 hover:nx-text-gray-900 dark:nx-text-neutral-200 dark:hover:nx-text-neutral-50 nx-flex nx-items-center">❰ <!-- -->Mnemofs</span></a><a class="nextra-card nx-group nx-flex nx-flex-col nx-justify-start nx-overflow-hidden nx-rounded-lg nx-border nx-border-gray-200 nx-text-current nx-no-underline dark:nx-shadow-none hover:nx-shadow-gray-100 dark:hover:nx-shadow-none nx-shadow-gray-100 active:nx-shadow-sm active:nx-shadow-gray-200 nx-transition-all nx-duration-200 hover:nx-border-gray-300 nx-bg-transparent nx-shadow-sm dark:nx-border-neutral-800 hover:nx-bg-slate-50 hover:nx-shadow-md dark:hover:nx-border-neutral-700 dark:hover:nx-bg-neutral-900" href="/blogs/mnemofs/journal/"><span class="nx-flex nx-font-semibold nx-items-start nx-gap-2 nx-p-4 nx-text-gray-700 hover:nx-text-gray-900 dark:nx-text-neutral-200 dark:hover:nx-text-neutral-50 nx-flex nx-items-center">❱ <!-- -->Mnemofs Journal</span></a></div>
<br/>
<a class="nextra-card nx-group nx-flex nx-flex-col nx-justify-start nx-overflow-hidden nx-rounded-lg nx-border nx-border-gray-200 nx-text-current nx-no-underline dark:nx-shadow-none hover:nx-shadow-gray-100 dark:hover:nx-shadow-none nx-shadow-gray-100 active:nx-shadow-sm active:nx-shadow-gray-200 nx-transition-all nx-duration-200 hover:nx-border-gray-300 nx-bg-transparent nx-shadow-sm dark:nx-border-neutral-800 hover:nx-bg-slate-50 hover:nx-shadow-md dark:hover:nx-border-neutral-700 dark:hover:nx-bg-neutral-900" href="/blogs/"><span class="nx-flex nx-font-semibold nx-items-start nx-gap-2 nx-p-4 nx-text-gray-700 hover:nx-text-gray-900 dark:nx-text-neutral-200 dark:hover:nx-text-neutral-50 nx-flex nx-items-center">⌂ <!-- -->Home</span></a><p>MIT 2024 © resyfer.</p></article></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{}},"page":"/mnemofs/lru","query":{},"buildId":"1Bm8E84dQAa3Fb_3ZJfyf","assetPrefix":"/blogs","nextExport":true,"autoExport":true,"isFallback":false,"scriptLoader":[]}</script></body></html>