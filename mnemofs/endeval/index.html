<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>Google Summer of Code &#x27;24 @ Apache NuttX Final Report</title><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-HFNGDFK1PN"></script><script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag(&#x27;js&#x27;, new Date());

        gtag(&#x27;config&#x27;, &#x27;G-HFNGDFK1PN&#x27;);
        </script><meta name="next-head-count" content="5"/><link rel="preload" href="/blogs/_next/static/css/a0de50ea0cc40a66.css" as="style"/><link rel="stylesheet" href="/blogs/_next/static/css/a0de50ea0cc40a66.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/blogs/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/blogs/_next/static/chunks/webpack-b7c95b972d7a52a1.js" defer=""></script><script src="/blogs/_next/static/chunks/framework-a85322f027b40e20.js" defer=""></script><script src="/blogs/_next/static/chunks/main-25a9149b204a716f.js" defer=""></script><script src="/blogs/_next/static/chunks/pages/_app-ae69650375182de2.js" defer=""></script><script src="/blogs/_next/static/chunks/253-8360a865f593540b.js" defer=""></script><script src="/blogs/_next/static/chunks/pages/mnemofs/endeval-4e25c490c26bc7da.js" defer=""></script><script src="/blogs/_next/static/xvVXqBqMjgQ6d2AA5_Hv1/_buildManifest.js" defer=""></script><script src="/blogs/_next/static/xvVXqBqMjgQ6d2AA5_Hv1/_ssgManifest.js" defer=""></script></head><body><div id="__next"><script>!function(){try{var d=document.documentElement,c=d.classList;c.remove('light','dark');var e=localStorage.getItem('theme');if('system'===e||(!e&&true)){var t='(prefers-color-scheme: dark)',m=window.matchMedia(t);if(m.media!==t||m.matches){d.style.colorScheme = 'dark';c.add('dark')}else{d.style.colorScheme = 'light';c.add('light')}}else if(e){c.add(e|| '')}if(e==='light'||e==='dark')d.style.colorScheme=e}catch(e){}}()</script><article class="nx-container nx-prose max-md:nx-prose-sm dark:nx-prose-dark" dir="ltr"><h1>Google Summer of Code &#x27;24 @ Apache NuttX Final Report</h1><div class="nx-mb-8 nx-flex nx-gap-3 nx-items-center"><div class="nx-grow dark:nx-text-gray-400 nx-text-gray-600"><div class="nx-not-prose nx-flex nx-flex-wrap nx-items-center nx-gap-1"></div></div><div class="nx-flex nx-items-center nx-gap-3 print:nx-hidden"></div></div>
<div class="nextra-callout nx-overflow-x-auto nx-mt-6 nx-flex nx-rounded-lg nx-border nx-py-2 ltr:nx-pr-4 rtl:nx-pl-4 contrast-more:nx-border-current contrast-more:dark:nx-border-current nx-border-blue-200 nx-bg-blue-100 nx-text-blue-900 dark:nx-border-blue-200/30 dark:nx-bg-blue-900/30 dark:nx-text-blue-200"><div class="nx-select-none nx-text-xl ltr:nx-pl-3 ltr:nx-pr-2 rtl:nx-pr-3 rtl:nx-pl-2" style="font-family:&quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;">ℹ️</div><div class="nx-w-full nx-min-w-0 nx-leading-7"><p><strong>TL;DR</strong>: NO! No shortcuts, it&#x27;s worth it I promise.</p></div></div>
<div style="text-align:justify"><p>Hi, I am Saurav Pal. I was a Google Summer of Code (GSoC) &#x27;24 contributor to the Apache NuttX Real Time Operating System (RTOS), working on designing and implementing mnemofs, a file system for NAND flashes, aiming at enabling file system support for the NAND flashes in the Apache NuttX RTOS.</p><p>I&#x27;ll be taking you through my entire work. Prerequisites you ask? None. Actually, you just need to know English. I&#x27;ll be explaining everything else.</p><h2 class="nx-not-prose subheading-h2">Storage devices<a href="#storage-devices" id="storage-devices" class="subheading-anchor" aria-label="Permalink for this section"></a></h2><p>A lot of storage devices are available like floppy disks. Ok, probably not the best example as some readers may not even have seen floppy disks in their lives. Compact Disks (CDs), Hard Disk Drives (HDDs), and Solid State Drives (SDDs) are some more popular and slightly more recent mediums of storage. NAND flashes are one such storage device.</p><p>When we talk about storage devices, we mean non-volatile memory. This means that the stored data is persistent even when power is no longer being provided to the storage device. Random Access Memory (RAM) is the standard example of a volatile memory medium, which loses all data once it loses power. Some common storage devices for embedded systems include: EPROM, EEPROM, NOR Flash and NAND Flash. NAND flashes and NOR flashes are very close competitiors, and are very often selected to be used on embedded system projects when someone doesn&#x27;t need too much storage.</p><h2 class="nx-not-prose subheading-h2">NAND vs NOR<a href="#nand-vs-nor" id="nand-vs-nor" class="subheading-anchor" aria-label="Permalink for this section"></a></h2><ins>Now, what are NAND gates or NOR gates?</ins><p>Good question, because it&#x27;s something you&#x27;re <strong>not</strong> required to know for this report.</p><ins>What are NAND or NOR flashes?</ins><p>Good question, because it&#x27;s something you&#x27;re required to know for this report.</p><br/><p>NAND and NOR flashes are made out of NAND and NOR gates (like mentioned above, not required to know). Formally, NAND flashes are a type of programmable, non-volatile storage technology built with cells of NAND gates.</p><p>Why, where, and which should I use? It&#x27;s complicated. NAND flashes require less number of lines in their structure and thus are more <strong>compact</strong> and <strong>cheaper</strong> than NOR flashes as they require less silicon for the same storage space. Sequential reads are faster in NAND flash, but NAND flashes are slower in random access reads. NOR flashes allow a single <a href="https://en.wikipedia.org/wiki/Word_(computer_architecture)" target="_blank" rel="noreferrer">machine word<span class="nx-sr-only nx-select-none"> (opens in a new tab)</span></a> to be written to an erased location or read independently. NAND flashes require reads or writes to be in pages, and erases to be in blocks (more on this later). Moreover, NAND flashes are more prone to random bit flipping, and a higher percentage of blocks turn out to be bad blocks right from manufacture, compared to NOR (again, further explanation below).</p><h2 class="nx-not-prose subheading-h2">Structure of NAND flashes<a href="#structure-of-nand-flashes" id="structure-of-nand-flashes" class="subheading-anchor" aria-label="Permalink for this section"></a></h2><p>The structure of NAND flashes is very multi-layered for others but simple for us. All we need to know is that a NAND flash is made up of tiny units called blocks, which are themselves made out of tinier units called pages, which further are made up of even tinier units called cells.</p><p>While we don&#x27;t have to think down to the cell level, it&#x27;s good to know some things about it. In a Single-Level Cell (SLC) NAND flash, each cell is one bit. There are other levels like Multi-Level Cell (MLC) NAND flashes and Triple-Level Cell (TLC) NAND flashes depending on the number of bits per cell.</p><p>What we do need to consider are pages and blocks. A block is the smallest erasable unit, while a page is the smallest readable or writeable unit. What is the role of erasable you might ask? Well, if a page was previously written to, it needs to be erased before it can be written again. But since a block is the smallest erasable unit, you&#x27;ll need to erase the entire block to update a certain page in the block. Another troublesome problem with the erase operation is that on every erase, a block is slightly more worn out than before. Upon repeated erase, it might not be able to reliably store data anymore, which means that it&#x27;s not guaranteed that the data you read from any page within the block is the data that was written to that page.</p><p>The onset of this state of the unreliability of a block means that the block is now a &quot;bad block&quot;. However, usage is not the sole cause of bad blocks in NAND flashes. Any good manufacturer tests their products before selling them. In the process of testing a NAND flash, some blocks might be deemed to be unfit for storage right from manufacture itself as they exhibit the unreliability of bad blocks, and are thus also clubbed under bad blocks.</p><p>Mentioned above is the tendency for NAND flashes to undergo random bit flipping. What is bit flipping? As the name suggests, the bits might flip sides (pretty treacherous, I know). This is a phenomenon not specific to NAND flashes, and over the years, people have come up with various solutions to deal with this. The solution NAND flashes use is to have some redundant bits to recognize and rectify bit flips, called Error Correction Code (ECC) bits. These parity bits may be stored on the page itself, but a common consensus has come up to keep these bits in a separate area on the page.</p><p>Thus, a page is split into two parts: a spare area, and a user data area. The user data area contains, well, the user data. The spare area contains the bits for ECC, even some bit(s) for bad block marking (called a bad block marker), and some other bits. A bad block marker is mostly used by the manufacturer to denote whether a particular block is a bad block.</p><h2 class="nx-not-prose subheading-h2">Virtual File System<a href="#virtual-file-system" id="virtual-file-system" class="subheading-anchor" aria-label="Permalink for this section"></a></h2><p>What you should know is that Apache NuttX, like most Operating Systems (OSes), has a <a href="https://www.merriam-webster.com/dictionary/subsystem" target="_blank" rel="noreferrer">subsystem<span class="nx-sr-only nx-select-none"> (opens in a new tab)</span></a> called the Virtual File System (VFS). This is technically not a file system itself, but it is tasked with the job of dealing with file systems. What you need to know is that the VFS mandates each file system, that aims to be used as part of an OS, to expose its functionality by following a fixed <a href="https://www.merriam-webster.com/dictionary/interface" target="_blank" rel="noreferrer">interface<span class="nx-sr-only nx-select-none"> (opens in a new tab)</span></a>. This means that the file system needs to follow some rules regarding what it is expected to do and it needs to follow some expectations of behaviour. This situation can be fully understood using a hypothetical situation I just made up.</p><p>Imagine the VFS doesn&#x27;t exist. You ask your OS to help save the text &quot;hello world&quot; to a file with a name and location of your choice. Now, without any standards of communication or expectations that come with these standards, it might be the case that, depending on which file system you choose, their functionality might range from doing nothing to probably hacking the <a href="https://www.nsa.gov/" target="_blank" rel="noreferrer">NSA<span class="nx-sr-only nx-select-none"> (opens in a new tab)</span></a>. This is chaos. The OS can&#x27;t decide which function to call from each FS for your desired task.</p><p>To enable this, either the OS needs to know the names of the functions of each file system, or the file systems have to mention the names of the functions that correspond to each functionality that the OS expects a file system to have. We have evolved to agree on the latter, as it puts the burden onto the poor FS developers like me, and also allows you to use file systems that might not be officially included in the OS, but rather, built by some sketchy guy you found on the dark web which you find to be surprisingly the fastest (and which seems to be making a lot of network requests sometimes <em>wink</em>).</p><p>Thus, this allows the side effects of a file system operations on the rest of the operating system to be uniform, defined, and predictable (on paper, at the very least) regardless of the file system being used. Thus, the rest of the OS, or even the user, does not need to care about the specifics of the underlying file system, and thus, a VFS enables an OS to be able to support multiple file systems at once. In short, a VFS mandates <strong>what</strong> the file system does, but not <strong>how</strong> they do it (this is where file systems differ from each other).</p><p>Further, let&#x27;s say, hypothetically, all FSes could hack the NSA and they each tell the OS the function that will start the hack as required by the VFS. Some day, a new FS is developed by a budding programmer who is not interested in these mundane and boring tasks. What the FS wants to do is launch some of the nuclear missiles that might be owned by your government. Now, this is unusual behaviour for a file system (in this hypothetical world). All file systems have stopped till the line of hacking the NSA. To enable this feature, the OS would need to expand its VFS. The latter part is what happens in the real world as well, though, I can not gaurantee about the former. Any new &quot;feature&quot; expected of file systems needs to be implemented by expanding the VFS. Also, if you can guess, after the expansion of the VFS, both FSes can co-exist. They both implement some features of the VFS, while ignoring others, which is perfectly fine.</p><div class="nextra-callout nx-overflow-x-auto nx-mt-6 nx-flex nx-rounded-lg nx-border nx-py-2 ltr:nx-pr-4 rtl:nx-pl-4 contrast-more:nx-border-current contrast-more:dark:nx-border-current nx-border-blue-200 nx-bg-blue-100 nx-text-blue-900 dark:nx-border-blue-200/30 dark:nx-bg-blue-900/30 dark:nx-text-blue-200"><div class="nx-select-none nx-text-xl ltr:nx-pl-3 ltr:nx-pr-2 rtl:nx-pr-3 rtl:nx-pl-2" style="font-family:&quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;">ℹ️</div><div class="nx-w-full nx-min-w-0 nx-leading-7"><p>Since we&#x27;re living in happier times, our file systems are content with just managing our storage devices. In fact, since we&#x27;re talking about standards, <a href="https://en.wikipedia.org/wiki/POSIX" target="_blank" rel="noreferrer">POSIX<span class="nx-sr-only nx-select-none"> (opens in a new tab)</span></a> has some of their own <a href="https://parallelstorage.com/2017/12/29/posix-file-system-basics/" target="_blank" rel="noreferrer">guidelines<span class="nx-sr-only nx-select-none"> (opens in a new tab)</span></a> on what a file system is expected to do.</p></div></div><h2 class="nx-not-prose subheading-h2">File System Constructs<a href="#file-system-constructs" id="file-system-constructs" class="subheading-anchor" aria-label="Permalink for this section"></a></h2><p>File systems ultimately help manage storing ones and zeroes onto storage devices to be painless for the user. They abstract away the peculiarities of the underlying electronic storage device, the pain of remembering the location of each bit of data, and many other such things. Over the years, file systems have evolved to agree on some basic concepts (with the help of <a href="https://en.wikipedia.org/wiki/Fear_of_missing_out" target="_blank" rel="noreferrer">FOMO<span class="nx-sr-only nx-select-none"> (opens in a new tab)</span></a> of the POSIX and the big-shots OS party). Almost all of these are OS enforced, so, unless your FS wants to do weird gymnastics to circumvent this architecture, it would be great if your FS follows this.</p><h3 class="nx-not-prose subheading-h3">Files and Directories<a href="#files-and-directories" id="files-and-directories" class="subheading-anchor" aria-label="Permalink for this section"></a></h3><p>Some of these constructs are namely files and folders/directories, often collectively called FS objects. You group data belonging to one specific thing as one file, while you arrange multiple files or other directories corresponding to each topic into one directory. It&#x27;s almost entirely dependent on where you draw the line.</p><h3 class="nx-not-prose subheading-h3">Root and Path<a href="#root-and-path" id="root-and-path" class="subheading-anchor" aria-label="Permalink for this section"></a></h3><p>Another of these constructs is the root of a file system and path. Root is the name given to the directory that contains all other files or directories, and is created by all file systems before you even use it. As you can see, this entire directory and file relationship gives rise to a <a href="https://en.wikipedia.org/wiki/Tree_(data_structure)" target="_blank" rel="noreferrer">tree-like structure<span class="nx-sr-only nx-select-none"> (opens in a new tab)</span></a>. Since a file can not have files inside it (that&#x27;s the job of a directory), the leaf nodes of the tree might be either files or empty directories. Further, the internal nodes of the tree will be directories, with the root node of the tree being the root of the file system, hence the name.</p><p>Let&#x27;s say, the root has a directory inside it with the name &quot;hello&quot;, and inside this directory, there is a file with the name &quot;world&quot;. The path is a construct that allows us to relate an FS object with its location. So, the file&#x27;s location, in this case, will be &quot;/hello/world&quot;. The root has no name (empty string), and each level is separated by a <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">/</code>.</p><h3 class="nx-not-prose subheading-h3">Mount Points<a href="#mount-points" id="mount-points" class="subheading-anchor" aria-label="Permalink for this section"></a></h3><p>Yet another construct of FSes is mount points. It&#x27;s a slightly complicated topic, so you need to read this part a bit slowly. So, you see, an FS works on a storage device. The storage device has to be formatted with the FS you want to use on it. Well, may be not ALL of the devices, if you consider <a href="https://en.wikipedia.org/wiki/Disk_partitioning" target="_blank" rel="noreferrer">partitions<span class="nx-sr-only nx-select-none"> (opens in a new tab)</span></a>. However, for the purposes of this report, we assume you want to format the entire device.</p><p>Your OS has its own preferred and internally supported file system that houses the root of the entire machine&#x27;s file system. This FS is given the title of &quot;rootfs&quot;. Rootfs is the title given to any FS that the OS picks to represent its entire FS tree&#x27;s root (<code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">/</code>). This root is the big guy, the supreme <a href="https://www.merriam-webster.com/dictionary/mugwump" target="_blank" rel="noreferrer">mugwump<span class="nx-sr-only nx-select-none"> (opens in a new tab)</span></a>. In the entire FS tree, nothing comes above it.</p><p>As it&#x27;s a file system, it will undoubtedly have its own tree. An interesting thing to note is that it&#x27;s not just the file systems that work with the VFS. VFS also works with device drivers, but it&#x27;s slightly out of the scope of this report. Just assume that we can work with devices through their device drivers in the same way we would work with a file. In Unix, <a href="https://en.wikipedia.org/wiki/Everything_is_a_file" target="_blank" rel="noreferrer">everything is a file<span class="nx-sr-only nx-select-none"> (opens in a new tab)</span></a>.</p><p>So, your storage driver works with VFS and is represented symbolically as a file in your device tree. If it&#x27;s a file, surely it must have a path right? Well, it does. Usually, Unix-based OSes put the device&#x27;s device file in the directory <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">/dev</code>. The path means there is a <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">dev</code> directory inside the root. This directory also belongs to the rootfs. Inside this will be a large number of files (and directories). Each file represents a device connected to your machine. Some of them may be physically present, and some might be logical devices (again, out of the scope of this report).</p><p>Now, let&#x27;s say, your NAND flash device connected to your machine is listed as the file <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">/dev/nand</code>, and you want to use <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">mnemofs</code> on it. Well, you can just <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">mount</code> it. What it means is that you tell the OS that this device is to be, or is already formatted with, mnemofs. Further, this also means you want to connect the file system that is present in this device to a preferred location in your rootfs.</p><p>Just like your rootfs has a root, so does the file system that&#x27;s present in your storage device. Root is nothing but the top-most guy. That may be globally true in the case of rootfs&#x27;s root, or locally true, in the case of roots of FSes formatted in the storage devices.</p><p>Mounting means attaching the local roots of the FSes in storage devices to locations in your rootfs tree. So, let&#x27;s say, your local root has two directories <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">a_local</code> and <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">b_local</code> inside it. You mount your local root to the path <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">/hi</code> and provide the correct file system type. This means that these two directories can now be located by anyone or anything on your machine using the paths <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">/hi/a_local</code> and <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">/hi/b_local</code> respectively.</p><p>Now, this might be confusing. You might think, if the device is already located at <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">/dev/nand</code>, why can&#x27;t I do something like <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">/dev/nand/a_local</code>? Now, that does make sense, but in Unix, there&#x27;s a distinction between device files and file systems.</p><p>Firstly, device files are files and are the leaf nodes of the FS tree. They are not supposed to do the work of directories, and root nodes (local or global) are directories. Second, device files are an interface to the device driver of the storage device. You can use this driver to give it instructions on what to store where in its device. But, why should I do this? Doesn&#x27;t this sound like the very thing file systems do? Yes. File systems, after being mounted, internally interact with your device&#x27;s device driver (using this device file). What file systems do is arrange the logical constructs called files and directories that are stored inside your device at a convenient location in your rootfs upon mounting.</p><p>The location where a file system is mounted is called a mount point. When it comes to mounting, we call the file system instance that was formatted onto the device the &quot;file system&quot;, and the type of file system as &quot;file system type&quot;. For example, in the NAND device mentioned above, <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">/hi</code> is the mount point and represents the file system (ie. the file system instance formatted onto the device), while <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">mnemofs</code> is the file system type.</p><p>Do note that one FS type is not necessarily limited to one mount point. There can be multiple devices using the same FS type. As an FS developer, it is important to not have any &quot;global variables&quot;, as each mount point is supposed to be independent of the other. All information needs to be instance-specific. How to do that? Well, patience. It will be explained later.</p><h2 class="nx-not-prose subheading-h2">Mnemofs<a href="#mnemofs" id="mnemofs" class="subheading-anchor" aria-label="Permalink for this section"></a></h2><p>Mnemofs is a file system built specifically to support NAND flashes for embedded systems using the Apache NuttX RTOS. Its components are a superblock, a master node, a journal, an LRU, and a block allocator (to name a few). These work in layers of abstraction, so I&#x27;ll walk you through them one by one.</p><p>Due to the peculiarities of NAND flashes, we do not want to &quot;update&quot; a page. To update a page, we&#x27;ll need to erase the entire block and write all of it (with the update) again. This will be very bad for block wear for multiple updates to the same block. Thus, we employ a tactic called Copy On Write (CoW). To update data in a file, we make a copy in memory, then update it, and then write the new information in a new place, and then update the location of this file.</p><p>Now, in its pure manner, Copy On Write cascades up to the root. Why? So, a file is updated by writing it in a new location. And the new location needs to be updated in its parent. Which again triggers CoW, and so on till it goes on upward in the FS tree till it reaches the local root (it might go on even further, but that&#x27;s dependent on the rootfs).</p><p>This illustration will explain it well:</p><p>Let&#x27;s assume the root (R) has a directory (A), which itself has a file (B).</p><p><img src="https://res.cloudinary.com/dbzi2yvvc/image/upload/c_fill,w_400/v1724418681/mnemofs/q842zgczpqzj0basdwvo.png" alt="og_state"/></p><p>Let&#x27;s assume we&#x27;ve updated file B to B&#x27;. This is how the entire process goes (in CoW&#x27;s pure manner):</p><p><img src="https://res.cloudinary.com/dbzi2yvvc/image/upload/c_fill,w_400/v1724418681/mnemofs/hn3udwd0notfmoyps0pb.png" alt="next_state1"/></p><p>Then the parent is updated as A&#x27;.</p><p><img src="https://res.cloudinary.com/dbzi2yvvc/image/upload/c_fill,w_400/v1724418681/mnemofs/twaurhfc3euszmqu0kvw.png" alt="next_state2"/></p><p>And then finally we go further up till we update the root R to R&#x27;.</p><p><img src="https://res.cloudinary.com/dbzi2yvvc/image/upload/c_fill,w_400/v1724418681/mnemofs/cmlateo0fyco1lz8ldfz.png" alt="next_state3"/></p><p>Then the old allocation are ready to be deleted.</p><p><img src="https://res.cloudinary.com/dbzi2yvvc/image/upload/c_fill,w_400/v1724418681/mnemofs/n8uczl70aiyr0qovx3sl.png" alt="final_state"/></p><p>For even one byte this goes up to the local root. A lot of writing for one byte right? Remember, the garbage left by CoW, ie. the pages that are old (and their data have been moved to another location), needs to be cleared when the page is to be used again. Mnemofs has measures to help mitigate this.</p><p>Also, file update seems to take a lot of memory if we have to copy the entire thing in memory, make updates, and save it to a new location right? Especially for large files? Well, we have measures to mitigate this as well.</p><h3 class="nx-not-prose subheading-h3">Superblock<a href="#superblock" id="superblock" class="subheading-anchor" aria-label="Permalink for this section"></a></h3><p>There are two versions of the superblock (SB). One that is formatted on the device, while the other that is present in memory. What is the difference? The former is pretty much useless for mnemofs, while mnemofs can&#x27;t be used without the latter.</p><p>The on-flash SB is just a magic sequence of 8 bytes and some information about the device and is stored in the very first good block in the storage. The only purpose it serves is to be a very quick reference on whether the device is formatted or not. Other than that it contains no information that can&#x27;t be obtained or derived from the device driver of the storage device. The on-flash SB, once formatted, is not updated. It&#x27;s there to stay. It&#x27;s pretty much symbolic and does not bring anything to the table.</p><p>The in-memory SB is stored in the private field of the driver and contains information about the device. Wait, but wasn&#x27;t it the same as above? Yes. The difference is, here we need to query the information from the device only once, and keep it in memory as part of in-memory SB. From then, this stored information will be used instead of querying the device again and again (it&#x27;s slower that way). It&#x27;s useful in-memory, but it hardly serves any purpose if stored on the flash.</p><h3 class="nx-not-prose subheading-h3">Block Allocator<a href="#block-allocator" id="block-allocator" class="subheading-anchor" aria-label="Permalink for this section"></a></h3><p>First, let&#x27;s get the dragon in the room out of the way. The block allocator. It&#x27;s a fairly separate component of the file system. Another component asks for a page or a block, and this allocates one for it and gives them the page or block number to it. Kind of like a hotel receptionist.</p><p>Let&#x27;s assume a hotel with all rooms identical. When a person is vacated, the room must be given a thorough cleaning before the next person is shifted in it. Also, assume the hotel cleaning staff will only thoroughly clean an entire floor at once, nothing less that than.</p><p>Let&#x27;s expand on the process of room allotment in such a hypothetical hotel. It&#x27;s best to allocate everything serially and cycle back to the beginning once you reach the end and continue. By the time you cycle back to a place, it may have been vacated since the last time you visited it and will be ready to be occupied again. Why is this the best? Because it ensures fairness to all the rooms and ensures the maximum wear difference of 1 between rooms when they will be cleaned.</p><p>Now, this can be applied to blocks and pages in our NAND flash. When pages are requested, the block allocator cycles through the available pages serially. It maintaines a bit mask to know which page is free or occupied by data.</p><p>Now, imagine a large group of people came, and demanded that they want to book an entire floor. Now the perfect sequential iteration plan has been thrown out of the window right? Well, the receptionist will just skip some rooms, keep them empty, and then allot them the nearest floor available. Now, a problem occurs. Your previous plan assumed no unoccupied room would be cleaned. Why wear down a room when it does not even need to be cleaned? So you change the meaning of the first bit mask to mean dirty rooms. And you keep another bit mask to know which rooms can be cleaned.</p><p>Once an entire floor is dirty and all the rooms on the floor can be cleaned, you call the cleaning crew. Until then, you only allocate pages that are cleaned. If a room is dirty and not ready to be cleaned, it means the resident is still occupying it. You can&#x27;t just throw them out after all.</p><p>This is basically how the block allocator works in mnemofs. In a cyclical sequential manner, it keeps allocating clean pages or blocks that do not have to be erased. There are some limitations on when a page marks itself as ready to be erased, and some caveats to the entire erase operation, but we&#x27;ll look into them later.</p><p>Suppose the receptionist dies one day, and a new guy takes over. This new guy doesn&#x27;t know which room the receptionist had last allotted. So, if he starts allotting from the start, then the problem is that the rooms at the start will have more wear. Imagine if it&#x27;s very common for receptionists to die. However unfortunate this incident will be, it will also pose a strong problem of wear misbalance in the hotel. Thus, each new receptionist will start from a random room instead of from the start.</p><p>The block allocator in mnemofs also starts from a random page every time it&#x27;s initialized. The receptionist dying can be correlated with power loss in embedded systems, ie. the death of the block allocator, as it stays purely in memory. Volatile memory remember?</p><h3 class="nx-not-prose subheading-h3">VFS Methods<a href="#vfs-methods" id="vfs-methods" class="subheading-anchor" aria-label="Permalink for this section"></a></h3><p>Mnemofs exposes its own functions corresponding to every VFS-mandated FS method. For example, the one corresponding to <a href="https://man7.org/linux/man-pages/man2/open.2.html" target="_blank" rel="noreferrer"><code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">open(2)</code><span class="nx-sr-only nx-select-none"> (opens in a new tab)</span></a> is the function <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">mnemofs_open</code>. Pretty intuitive right? Yeah. All sunshine in this section. Any VFS method is basically <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">mnemofs_&lt;method-name&gt;</code>.</p><p>These VFS methods usually have some functionalities related to traversing the directories, creating new FS objects, removing FS objects, moving FS objects, getting stats of FS objects, updating FS objects, and reading FS objects.</p><h3 class="nx-not-prose subheading-h3">R/W Layer<a href="#rw-layer" id="rw-layer" class="subheading-anchor" aria-label="Permalink for this section"></a></h3><p>This layer is very simple. You give a byte array <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">101101011010101110101110</code> (3 bytes) and tell it to store this on page <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">4</code>, and it will either do it well, or return an error (either a bad block, or if the page is already written to, or if the device is not found, etc.), or it can also help you read the contents of a page.</p><p>It can also mark any block you want as a bad block, and even check if a block is bad or not.</p><p>Very simple stuff and this is the layer that works directly with the device driver of the storage device.</p><h3 class="nx-not-prose subheading-h3">CTZ Layer<a href="#ctz-layer" id="ctz-layer" class="subheading-anchor" aria-label="Permalink for this section"></a></h3><p>Mnemofs stores files and directories as Count Trailing Zero (CTZ) lists. These are a kind of backward skip list <a href="https://github.com/littlefs-project/littlefs/blob/master/DESIGN.md#ctz-skip-lists" target="_blank" rel="noreferrer">pioneered by littlefs<span class="nx-sr-only nx-select-none"> (opens in a new tab)</span></a>, which follow a predictable pattern. Mnemofs doesn&#x27;t follow this design word for word, but there are very minor changes, which do not bring any extra improvements to the table. CTZ lists are very good for updating, and especially appending, data to an existing file as governed by the as illustrated by the <a href="https://github.com/littlefs-project/littlefs/blob/master/DESIGN.md#ctz-skip-lists" target="_blank" rel="noreferrer">littlefs design specifications<span class="nx-sr-only nx-select-none"> (opens in a new tab)</span></a>.</p><p>So, I&#x27;ll be explaining the mnemofs version (which may overlap with the littlefs version in most ways). CTZ skip lists are made out of CTZ blocks. Each CTZ block in mnemofs takes up the space of one single page. The naming is kept like this to preserve the original nomenclature. Each CTZ block has a &quot;data&quot; section, and a &quot;pointer&quot; section. CTZ lists have a storage overhead of 2 bytes on average per CTZ block (again, as derived by the littlefs team), and this means that on average, each page will have 8 bytes of pointers in mnemofs, which I think is the best deal I&#x27;ve heard in quite a while. Most pages are usually more than 512 B, which makes the overhead at a maximum of 1.5%.</p><p>Formally, every CTZ block at index <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">i</code> (<a href="https://en.wikipedia.org/wiki/Zero-based_numbering" target="_blank" rel="noreferrer">0-based indexing<span class="nx-sr-only nx-select-none"> (opens in a new tab)</span></a>) has a pointer for every whole number <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">x</code> such that <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">i - 2^x &gt;= 0</code> and <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">i</code> is divisible by <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">2^x</code>. Examples will explain it much better. A CTZ block with index <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">6</code> will have pointers to <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">5</code> (6 - 1) and <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">4</code> (6 - 2). A CTZ block with index <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">4</code> will have pointers to <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">3</code> (4 - 1), <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">2</code> (4 - 2) and <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">0</code> (4 - 4). Also, a CTZ block with index <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">5</code> will have a pointer to <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">4</code> (5 - 1). In mnemofs, the pointer to <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">i - 2^x</code> lies in the byte range <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">[page_start + page_size - (4 * (x + 1)), page_start + page_size - (4 * x))</code>. Each pointer takes up 4 bytes of space, and it&#x27;s created as a bottom-up approach, where the pointer to the immediate neighbour is the last, and the furthest neighbour&#x27;s pointer appears the first out of the pointers.</p><p>So, apart from the area reserved for the pointers at the end of the page, the rest of the area at the front is for storing the data. This CTZ layer abstracts the data area and makes it seem like it&#x27;s a single contiguous space for storage.</p><p>For example, if the page size is 128 bytes, then the first block (index 0) has 128 bytes of data area, and the second and third blocks have 124 and 120 bytes of data area respectively and so on. So, if you had to store, say, 255 bytes of data, the layer just takes in the array you want to store, and the CTZ list, and this layer will split into (128 + 124 + 3) bytes. This means that the data area of the first two blocks will be full, while the third block (index 2) will have only 3 bytes at the front.</p><p>This abstraction is also applicable for reading data from the CTZ list. Everything happens under the hood.</p><p>Littlefs developers have derived a very convenient method of finding out the CTZ block index and CTZ block offset (ie. page offset in mnemofs) from the data offset (ie. offset into the data area, assuming it to be a contiguous space). They&#x27;ve also demonstrated how a CTZ list can be identified by just using the location (page number) of the last CTZ block and the index number of the last CTZ block.</p><p>Over that CTZ lists are quite suitable for updates in CoW environments, as shown by the design document as well. The part before the update is kept the same, and the later part is updated and written to a new location.</p><h3 class="nx-not-prose subheading-h3">Files and Directories<a href="#files-and-directories-1" id="files-and-directories-1" class="subheading-anchor" aria-label="Permalink for this section"></a></h3><p>Files and directories are represented by CTZ lists. While the file contains only the data included in the file, the directories are basically files that contain the list of FS objects inside them. We call the entries in this list as directory entries or direntries. These direntries contain metadata about the FS object they point to name, size, location, time created, time modified, etc.</p><h3 class="nx-not-prose subheading-h3">Journal<a href="#journal" id="journal" class="subheading-anchor" aria-label="Permalink for this section"></a></h3><p>Mnemofs uses a journal. Combining the CoW tactic and a journal will allow mnemofs to be resilient to power losses. How? Well, let me explain what a journal does.</p><p>So, let&#x27;s say, we make a change to a file. This file now has a new location. This, as discussed above, goes on to cascade to the local root. Suppose, in the middle of the copy, there&#x27;s a power loss. The entire work of updating needs to be done again. Instead what we do is that we just write the new location of the file as a log to the journal. So, when we want to get the location of the file, we first traverse the FS tree to get the old location, then traverse the journal to get the new location.</p><p>This also saves from updating the parent immediately, since it doesn&#x27;t need to be updated in the parent as long as the log of the update remains in the journal. Each log is appended by a checksum of it to ensure that the entire log was fully written, and that there were no power losses in between.</p><p>The journal is a singly linked list made out of entire blocks, and each log and its checksum take up an entire page (for now). After the journal is full or above a certain limit, it will be flushed to empty it, but we&#x27;ll discuss this later.</p><h3 class="nx-not-prose subheading-h3">Master Node and Journal Flushing<a href="#master-node-and-journal-flushing" id="master-node-and-journal-flushing" class="subheading-anchor" aria-label="Permalink for this section"></a></h3><p>Mnemofs has a component called a master node. This master node basically points to the root of the file system. This allows the root to be treated like any other file as far as space allocation goes.</p><p>Where does the master node live? In a very special location. You see, the journal is made out of <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">n + 2</code> blocks, such that the first <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">n</code> blocks are the only blocks that are in charge of storing the logs. The last two blocks are called the master blocks. The two master blocks are identical to each other and act as each others&#x27; backups, given that the master node allows you to make sense out of the ones and zeroes stored on your device. So, master nodes are stored in the master blocks, not too unlike how logs are stored. The entire information about the root is stored along with a checksum and a timestamp. These are serially stored, so the last valid log entry points to the actual current master node.</p><p>When a journal is flushed, the entire local FS tree is updated. The update of a child means storing the updated location in the parent, which also means the parent is getting updated as well, and so on till the root has another updated copy of the root. Once we get the location of the new root, we know our flush operation has been completed. Since updating the root also means the master node is updated, a corresponding new entry is <a href="https://www.merriam-webster.com/dictionary/append" target="_blank" rel="noreferrer">appended<span class="nx-sr-only nx-select-none"> (opens in a new tab)</span></a> in both master blocks. This new entry is a new master node.</p><p>We make the journal&#x27;s blocks follow the same wear rules as the other blocks. The moment it is to be erased, the block is given back to the block allocator as a &quot;to-be erased block&quot;, and it is only used again (after erase) after ensuring every other block in the entire device is used once, but more on this later. So, every time a journal is flushed, it has to &quot;move&quot; to a new location.</p><p>Each time a journal is updated, a new master node gets written. Since a block has multiple pages, and a master node takes up one page, then there can be a <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">pages_per_block</code> number of master node entries, and thus a <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">pages_per_block</code> number of journal flushes, before the master blocks are full. Thus, the first <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">n</code> blocks of the journal move much more than the last two blocks. Upon the <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">pages_per_block + 1</code>th flush <strong>all</strong> of the <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">n + 2</code> blocks are flushed, and thus the entire journal moves in this case.</p><h3 class="nx-not-prose subheading-h3">Least Recently Used Cache<a href="#least-recently-used-cache" id="least-recently-used-cache" class="subheading-anchor" aria-label="Permalink for this section"></a></h3><p>Well, first of all, my naming sense is bad. It&#x27;s the Least Recently Used Cache. You can call it a cache, as it&#x27;s like a twin to it. But in the case of mnemofs, it doesn&#x27;t provide any benefit of being a cache, as far as read times are concerned. So we&#x27;ll just call it the LRU.</p><p>Why doesn&#x27;t it provide any benefit of being a cache? Well, we need to discuss what it does first. The LRU&#x27;s job is to effectively store all the changes a user requests in memory. Then, say for a single file, when a lot of these changes have been stored, they are applied to the flash <strong>together</strong>. So, let&#x27;s say we wait for <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">n</code> operations from the user before emptying the changes of a file stored in LRU. That would mark it as <strong>one</strong> operation to the flash for <strong>every</strong> <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">n</code> operations. We can have the entire size of the LRU to be configurable, to allow users to pick their own sweet balance between memory consumption and flash wear reduction.</p><p>We still haven&#x27;t answered the initial question yet. But before that, we <em>also</em> need to look into the structure of the LRU. The LRU is made out of something called a <a href="https://kernelnewbies.org/FAQ/LinkedLists" target="_blank" rel="noreferrer">kernel list<span class="nx-sr-only nx-select-none"> (opens in a new tab)</span></a>. For the uninterest people, it&#x27;s simply a clever way to write circular doubly linked lists. The kernel list in LRU contains several <strong>nodes</strong>. Each node represents an FS object, be it a file or a directory. Now, each node itself has a kernel list as well. This list is made out of what mnemofs calls <strong>deltas</strong>. Each delta is an operation by the user. To the person who takes pain to understand the VFS methods, it is clear that the VFS methods, at their base, deal with some fundamental operations on FS objects. Namely, either reading, updating (and writing), or deleting some bytes.</p><p>Mnemofs has some further restrictions on this, to allow the usage of this LRU to be a bit simpler. When it comes to updating, VFS methods can ask you to put <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">m</code> bytes in place of <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">n</code> bytes. However, the way mnemofs works, we force this to follow the condition <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">m == n</code> (we&#x27;ll discuss about this a bit later). If you&#x27;re writing to a file, it will be replacing <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">n</code> bytes of 0-byte filled data, with <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">n</code> bytes of actual data, and so on. And then there&#x27;s the delete operation, where we remove <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">n</code> bytes of data. Both operations start at a specific offset, which menmofs calls a &quot;data offset&quot; (as it&#x27;s offset inside the data stored in the CTZ lists).</p><p>When an LRU receives a delta for a specific node, it will bump the node from wherever it is, to the start of the LRU. This way, the last node is always the least recently used node. When the LRU becomes full, and wants to add a new node, it will pop out the last node before adding the new node. This pop will follow with the deltas being actually written to the flash, and then having their corresponding log in the journal.</p><p>Now, finally, the answer to the initial question. Well, thanks for waiting this long, but I&#x27;m afraid you&#x27;ll have to wait a bit more! I&#x27;ll have to explain the entire process through which all components work together to be able to make you understand, so please bear with me.</p><h2 class="nx-not-prose subheading-h2">Entire process<a href="#entire-process" id="entire-process" class="subheading-anchor" aria-label="Permalink for this section"></a></h2><p>Well, the user makes a <a href="https://en.wikipedia.org/wiki/System_call" target="_blank" rel="noreferrer">syscall<span class="nx-sr-only nx-select-none"> (opens in a new tab)</span></a> (directly or indirectly) to do something with a file or a directory. This is then transferred to the VFS, who find the right file system to deal with the request. How? Well, the path provided by the user, and the mount points of file systems help in this. So, let&#x27;s say we&#x27;re lucky the user refers to mnemofs.</p><p>Mnemofs then deals with the request appropriately. Let&#x27;s say, it deals with reading 5 bytes from an offset of 10 in the file. What file the user is referring to needs to be found. First, the current master node is consulted to get the location of the root. Once we get the root, we traverse the directory entries (direntries) in it to find the suitable FS object that the path refers to after the root, and so on, till we either reach the intended path, or give an error of not finding the desired FS object.</p><p>What we got here might be an old location for the intended FS object, so we traverse through the journal to find the newly updated location. Once we get the new location, we read the data stored in the list. However, this data might be old as well, as the LRU contains the latest data. So, we apply the changes to the CTZ list from the LRU. We do this cleverly to allow the changes to be applied in memory, and in chunks, to set an upper bound on the memory usage.</p><p>Thus, we get the updated information. Since the LRU comes last in this process, that&#x27;s why it doesn&#x27;t behave like a cache per se.</p><p>Let&#x27;s say we want to delete some data. Most of the previous process will be the same. In this case, we just add the fact that we want to delete <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">n</code> bytes from <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">m</code> offset in the node corresponding to this file as a delta, and the node will be bumped to be at the start of the LRU. If the node gets full, and another delta is to be added, the node will be emptied of all deltas, which means, they will be written to the flash. Similarly, when the LRU gets full of nodes, and another node is to be added, the last node is popped, and written to the flash. When the changes are clubbed together and written to the flash, their new location is updated in the journal as a log, followed by their checksum.</p><p>Now, if the journal is above a certain limit (usually 50% full), the journal is flushed. The file system enters a state of flush. All the changes in the journal are written. However, this will cause changes in their parents, and these changes will go through the same process that all changes do in mnemofs. Then the flush will be repeated again, and again. Do note that the journal has not been erased yet. The reason why we flush the journal when it reaches a certain limit, is to keep space for the logs of their parents and ancestors during the entire flush operation. So, this way, when we finally reach to the top of the local FS tree, the new root is written, and a corresponding new master node is written.</p><p>Once this master node is written, the entire flush operation is basically complete. We just wipe the entire journal clean. We do not need the logs anymore. Why? Once an FS object&#x27;s latest log is written, all the logs of its children are useless, as the new location already is updated with the latest locations of its descendants. As the local root is the highest you can go in the local FS tree, once its log is written (which is the master node entry), all other logs are not required, and can be erased freely.</p><p>Now, sometimes, the master nodes might be full, in which case a new journal and new master blocks are allocated space, and then the new master node is written to it. The master node also contains the location of the journal, and thus, this new journal will instantly become the new journal once the master node is written to it, and the old journal and its master blocks are given back to the block allocator to be erased.</p><p>Now, till the new master node is not written, none of the pages related to old locations should be erased. Why? Imagine we have a power loss, and we want to retrieve the old state of the file system, only to find your dear block allocator has erased them thinking they won&#x27;t be needing that. Turns out you <strong>do</strong> need that don&#x27;t you? So, once the new master node is written, only then will any erase operations happen. During the flush operation, all the pages containing old data mark themselves as &quot;to-be erased&quot;, however, only when the new master node is written, will the block allocator scan through all the pages that want to be erased to check for entire blocks that want to be erased, and then erase them.</p><h2 class="nx-not-prose subheading-h2">My Pull Requests<a href="#my-pull-requests" id="my-pull-requests" class="subheading-anchor" aria-label="Permalink for this section"></a></h2><p>My contribution was to implement mnemofs to a working state. It&#x27;s not feature complete yet, however, it&#x27;s very close to being so. These were my contributions related to the project and tools related to my work on this project:</p><ul>
<li><a href="https://github.com/apache/nuttx/pull/11806" target="_blank" rel="noreferrer">#11806 drivers/mtd/mtd_nandram: Adds virtual NAND Flash simulator<span class="nx-sr-only nx-select-none"> (opens in a new tab)</span></a></li>
<li><a href="https://github.com/apache/nuttx/pull/12395" target="_blank" rel="noreferrer">#12396 fs/mnemofs: Adds mnemofs and mnemofs journal<span class="nx-sr-only nx-select-none"> (opens in a new tab)</span></a></li>
<li><a href="https://github.com/apache/nuttx/pull/12658" target="_blank" rel="noreferrer">#12658 fs/mnemofs: Setup and VFS methods<span class="nx-sr-only nx-select-none"> (opens in a new tab)</span></a></li>
<li><a href="https://github.com/apache/nuttx/pull/12661" target="_blank" rel="noreferrer">#12661 fs/mnemofs: Add Block Allocator<span class="nx-sr-only nx-select-none"> (opens in a new tab)</span></a></li>
<li><a href="https://github.com/apache/nuttx/pull/12668" target="_blank" rel="noreferrer">#12668 fs/mnemofs: Add parent iterator and path methods.<span class="nx-sr-only nx-select-none"> (opens in a new tab)</span></a></li>
<li><a href="https://github.com/apache/nuttx/pull/12680" target="_blank" rel="noreferrer">#12680 fs/mnemofs: Add LRU and CTZ methods<span class="nx-sr-only nx-select-none"> (opens in a new tab)</span></a></li>
<li><a href="https://github.com/apache/nuttx/pull/12683" target="_blank" rel="noreferrer">#12683 fs/mnemofs: Add journal methods.<span class="nx-sr-only nx-select-none"> (opens in a new tab)</span></a></li>
<li><a href="https://github.com/apache/nuttx/pull/12702" target="_blank" rel="noreferrer">#12701 fs/mnemofs: Add master node and r/w methods<span class="nx-sr-only nx-select-none"> (opens in a new tab)</span></a></li>
<li><a href="https://github.com/apache/nuttx/pull/12808" target="_blank" rel="noreferrer">#12808 fs/mnemofs: Refactoring path logic, direntry size bug fix, open free bug fix<span class="nx-sr-only nx-select-none"> (opens in a new tab)</span></a></li>
<li><a href="https://github.com/apache/nuttx/pull/12937" target="_blank" rel="noreferrer">#12937 fs/mnemofs: Fix journal log rw issue, rw size issue<span class="nx-sr-only nx-select-none"> (opens in a new tab)</span></a></li>
<li><a href="https://github.com/apache/nuttx/pull/12943" target="_blank" rel="noreferrer">#12943 fs/mnemofs: Autoformat<span class="nx-sr-only nx-select-none"> (opens in a new tab)</span></a></li>
</ul><p>Further, before GSoC, I&#x27;ve made some contributions while getting started with the codebase:</p><ul>
<li><a href="https://github.com/apache/nuttx/pull/11647" target="_blank" rel="noreferrer">#11647 fs/vfat: Fix typo in the macro DIRSEC_BYTENDX<span class="nx-sr-only nx-select-none"> (opens in a new tab)</span></a></li>
<li><a href="https://github.com/apache/nuttx/pull/11656" target="_blank" rel="noreferrer">#11656 docs/fs/vfat: Improve VFAT documentation<span class="nx-sr-only nx-select-none"> (opens in a new tab)</span></a></li>
<li><a href="https://github.com/apache/nuttx/pull/11730" target="_blank" rel="noreferrer">#11730 fs: Add VFS docs<span class="nx-sr-only nx-select-none"> (opens in a new tab)</span></a></li>
</ul><h2 class="nx-not-prose subheading-h2">Conclusion<a href="#conclusion" id="conclusion" class="subheading-anchor" aria-label="Permalink for this section"></a></h2><p>I&#x27;ve had a very great time contributing to Apache NuttX, and I plan to keep continuing my contributions to both mnemofs and the entire Apache NuttX codebase as well. I had the fortune of working under a great mentor, <a href="https://github.com/acassis" target="_blank" rel="noreferrer">Alan<span class="nx-sr-only nx-select-none"> (opens in a new tab)</span></a>, along with the entire (very supportive) Apache NuttX community. I can not thank them enough for giving me the chance and considering me as a suitable contributor for GSoC &#x27;24 for this ambitious project. Further, I&#x27;ve had the pleasure of being at the receiving end of the waterfall of knowledge that&#x27;s written by the littlefs team in their <a href="https://github.com/littlefs-project/littlefs/blob/master/DESIGN.md" target="_blank" rel="noreferrer">design document<span class="nx-sr-only nx-select-none"> (opens in a new tab)</span></a>.</p><p>Last but not least, I&#x27;ve had the fortune of having the immense support of my parents, friends, co-contributor Rushabh, and co-workers in this entire journey, without whom I could not have done it.</p><p>Thank you to you too for reading this far.</p></div>
<hr/>
<div class="nextra-cards nx-mt-4 nx-gap-4 nx-grid nx-not-prose" style="--rows:3"><a class="nextra-card nx-group nx-flex nx-flex-col nx-justify-start nx-overflow-hidden nx-rounded-lg nx-border nx-border-gray-200 nx-text-current nx-no-underline dark:nx-shadow-none hover:nx-shadow-gray-100 dark:hover:nx-shadow-none nx-shadow-gray-100 active:nx-shadow-sm active:nx-shadow-gray-200 nx-transition-all nx-duration-200 hover:nx-border-gray-300 nx-bg-transparent nx-shadow-sm dark:nx-border-neutral-800 hover:nx-bg-slate-50 hover:nx-shadow-md dark:hover:nx-border-neutral-700 dark:hover:nx-bg-neutral-900" href="/blogs/mnemofs/mideval/"><span class="nx-flex nx-font-semibold nx-items-start nx-gap-2 nx-p-4 nx-text-gray-700 hover:nx-text-gray-900 dark:nx-text-neutral-200 dark:hover:nx-text-neutral-50 nx-flex nx-items-center">❰ <!-- -->GSoC &#x27;24 @ Apache NuttX, Mid Term Evaluation Blog</span></a><a class="nextra-card nx-group nx-flex nx-flex-col nx-justify-start nx-overflow-hidden nx-rounded-lg nx-border nx-border-gray-200 nx-text-current nx-no-underline dark:nx-shadow-none hover:nx-shadow-gray-100 dark:hover:nx-shadow-none nx-shadow-gray-100 active:nx-shadow-sm active:nx-shadow-gray-200 nx-transition-all nx-duration-200 hover:nx-border-gray-300 nx-bg-transparent nx-shadow-sm dark:nx-border-neutral-800 hover:nx-bg-slate-50 hover:nx-shadow-md dark:hover:nx-border-neutral-700 dark:hover:nx-bg-neutral-900" href="/blogs/mnemofs/mnemofs/"><span class="nx-flex nx-font-semibold nx-items-start nx-gap-2 nx-p-4 nx-text-gray-700 hover:nx-text-gray-900 dark:nx-text-neutral-200 dark:hover:nx-text-neutral-50 nx-flex nx-items-center">❱ <!-- -->Mnemofs</span></a></div>
<br/>
<a class="nextra-card nx-group nx-flex nx-flex-col nx-justify-start nx-overflow-hidden nx-rounded-lg nx-border nx-border-gray-200 nx-text-current nx-no-underline dark:nx-shadow-none hover:nx-shadow-gray-100 dark:hover:nx-shadow-none nx-shadow-gray-100 active:nx-shadow-sm active:nx-shadow-gray-200 nx-transition-all nx-duration-200 hover:nx-border-gray-300 nx-bg-transparent nx-shadow-sm dark:nx-border-neutral-800 hover:nx-bg-slate-50 hover:nx-shadow-md dark:hover:nx-border-neutral-700 dark:hover:nx-bg-neutral-900" href="/blogs/"><span class="nx-flex nx-font-semibold nx-items-start nx-gap-2 nx-p-4 nx-text-gray-700 hover:nx-text-gray-900 dark:nx-text-neutral-200 dark:hover:nx-text-neutral-50 nx-flex nx-items-center">⌂ <!-- -->Home</span></a><p>MIT 2024 © resyfer.</p></article></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{}},"page":"/mnemofs/endeval","query":{},"buildId":"xvVXqBqMjgQ6d2AA5_Hv1","assetPrefix":"/blogs","nextExport":true,"autoExport":true,"isFallback":false,"scriptLoader":[]}</script></body></html>