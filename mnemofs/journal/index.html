<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>Mnemofs&#x27;s Journal</title><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-HFNGDFK1PN"></script><script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag(&#x27;js&#x27;, new Date());

        gtag(&#x27;config&#x27;, &#x27;G-HFNGDFK1PN&#x27;);
        </script><meta name="next-head-count" content="5"/><link rel="preload" href="/blogs/_next/static/css/a0de50ea0cc40a66.css" as="style"/><link rel="stylesheet" href="/blogs/_next/static/css/a0de50ea0cc40a66.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/blogs/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/blogs/_next/static/chunks/webpack-b7c95b972d7a52a1.js" defer=""></script><script src="/blogs/_next/static/chunks/framework-a85322f027b40e20.js" defer=""></script><script src="/blogs/_next/static/chunks/main-25a9149b204a716f.js" defer=""></script><script src="/blogs/_next/static/chunks/pages/_app-ae69650375182de2.js" defer=""></script><script src="/blogs/_next/static/chunks/253-8360a865f593540b.js" defer=""></script><script src="/blogs/_next/static/chunks/pages/mnemofs/journal-ee8da2aba51175f4.js" defer=""></script><script src="/blogs/_next/static/2hS5wJtVXvVRna5Z6FRwt/_buildManifest.js" defer=""></script><script src="/blogs/_next/static/2hS5wJtVXvVRna5Z6FRwt/_ssgManifest.js" defer=""></script></head><body><div id="__next"><script>!function(){try{var d=document.documentElement,c=d.classList;c.remove('light','dark');var e=localStorage.getItem('theme');if('system'===e||(!e&&true)){var t='(prefers-color-scheme: dark)',m=window.matchMedia(t);if(m.media!==t||m.matches){d.style.colorScheme = 'dark';c.add('dark')}else{d.style.colorScheme = 'light';c.add('light')}}else if(e){c.add(e|| '')}if(e==='light'||e==='dark')d.style.colorScheme=e}catch(e){}}()</script><article class="nx-container nx-prose max-md:nx-prose-sm dark:nx-prose-dark" dir="ltr"><h1>Mnemofs&#x27;s Journal</h1><div class="nx-mb-8 nx-flex nx-gap-3 nx-items-center"><div class="nx-grow dark:nx-text-gray-400 nx-text-gray-600"><div class="nx-not-prose nx-flex nx-flex-wrap nx-items-center nx-gap-1"></div></div><div class="nx-flex nx-items-center nx-gap-3 print:nx-hidden"></div></div><div style="text-align:justify"><p>Continuing a reoccurring theme, to understand this, we need to understand something else. Since the journal stores updated information about a file or a directory, first we need to look into how mnemofs stores a file or a directory.</p><h2 class="nx-not-prose subheading-h2">Count Trailing Zero (CTZ)<a href="#count-trailing-zero-ctz" id="count-trailing-zero-ctz" class="subheading-anchor" aria-label="Permalink for this section"></a></h2><p>On a seemingly unrelated note, have you heard of the CTZ operation? It, as its name suggests, counts the number of trailing zeros in the binary representation of a number.</p><p>e.g., 1860 is <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">11101000100</code> in binary, and there are <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">2</code> trailing zeroes in it. Thus, <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">ctz(1860) == 2</code>.</p><p>GNU compilers provide a <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">__builtin_ctz(x)</code> for this, and in C 23, it&#x27;s become a part of the official standard. Most CPU architectures support this instruction.</p><h3 class="nx-not-prose subheading-h3">CTZ Skip List<a href="#ctz-skip-list" id="ctz-skip-list" class="subheading-anchor" aria-label="Permalink for this section"></a></h3><p>A skip list is a modified singly linked list that, instead of containing one pointer per node to point to the next node, contains more pointers in <strong>addition</strong> to the original pointer. Also, as shown by <a href="https://github.com/littlefs-project/littlefs/blob/master/DESIGN.md#ctz-skip-lists" target="_blank" rel="noreferrer">littlefs (who pioneered the CTZ skip list data structure)<span class="nx-sr-only nx-select-none"> (opens in a new tab)</span></a>, Copy-On-Write benefits more from a backward linked list (or a backward skip list) than a forward skip list.</p><p>Skip lists prefer to keep the number of pointers per node at random to lower the cost of insertion and deletion. However, a Copy-On-Write file system has no need for &quot;insertion&quot; and &quot;deletion.&quot; All of the operations are in the form of &quot;appending&quot; and all modifications requested are done in memory. We&#x27;ll discuss how a CTZ skip list works in mnemofs, but first we need to know what the structure of a CTZ skip list is.</p><p>In CTZ skip lists, each CTZ skip list block at index <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">x</code> has <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">ctz(x) + 1</code> number of pointers (0 for the 0th CTZ skip list block). Each CTZ skip list block has pointer to the <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">(x - 2^i)</code>th CTZ skip list block for every <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">i</code> such that <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">x</code> is divisible by <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">2^i</code>. For example, a CTZ skip list block with index <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">6</code> will have pointers to <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">5</code>th and <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">4</code>th CTZ skip list blocks, while a CTZ skip list block with index <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">8</code> will have pointers to <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">7</code>th, <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">6</code>th, <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">4</code>th, and <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">0</code>th CTZ skip list blocks.</p><p>In mnemofs, each CTZ skip list block takes exactly one page of space.</p><p>Since it&#x27;s possible to iterate over a CTZ skip list to reach any CTZ skip list block from the very last CTZ skip list block, only the page number and index of the last CTZ skip list block are stored, along with the size of the file. Mnemofs uses CTZ skip lists like its creator, littefs, does. However, mnemofs uses it to represent files <strong>and</strong> directories.</p><h3 class="nx-not-prose subheading-h3">Travel and Offset<a href="#travel-and-offset" id="travel-and-offset" class="subheading-anchor" aria-label="Permalink for this section"></a></h3><p>We&#x27;ll use the word &quot;offset&quot; to refer to &quot;data offset,&quot; which is the offset into the actual data contained in the CTZ skip list, which doesn&#x27;t include the pointers.</p><p>Conversion of the offset into its CTZ skip list block index and page offset can be done through the derivations done by <a href="https://github.com/littlefs-project/littlefs/blob/master/DESIGN.md#ctz-skip-lists" target="_blank" rel="noreferrer">littlefs<span class="nx-sr-only nx-select-none"> (opens in a new tab)</span></a>.</p><p>Travel from one CTZ skip list block to the other can be done using a greedy approach that utilizes the fact that the powers of 2 that change from one CTZ skip list block to the other while traveling first monotonically increase and then monotonically decrease. The graph <em>might</em> be discontinuous, but that&#x27;s not an issue. It&#x27;s actually easier to understand by reading the code in this case.</p><h2 class="nx-not-prose subheading-h2">Journal Logs<a href="#journal-logs" id="journal-logs" class="subheading-anchor" aria-label="Permalink for this section"></a></h2><p>Back to the journal. Now, once the updated information on the CTZ skip list is received, it is logged to the journal along with a CTZ skip list representation of the path of the FS object. This log is followed by a checksum to make sure that the entire log was written correctly to the flash.</p><h3 class="nx-not-prose subheading-h3">Structure<a href="#structure" id="structure" class="subheading-anchor" aria-label="Permalink for this section"></a></h3><p>The journal consists of blocks from the NAND flash. The last two blocks allocated for the journal are reserved for the master node and are called master blocks (more on that later). The first block starts with an 8-byte magic sequence, followed by the number of blocks (all <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">n + 2</code> blocks) allocated to the journal, and then an array that contains the block numbers of all the blocks allocated to the journal.</p><p>This is like a modified version of a singly linked list. A traditional singly linked list design was not used to allow the mount process to quickly find the master node once the journal was found (more on that later), and it reduces space, as a traditional design would require the last page of every block in the journal to be reserved specifically for storing the block number of the next block.</p><p>The first <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">n</code> blocks (out of the <code class="nx-border-black nx-border-opacity-[0.04] nx-bg-opacity-[0.03] nx-bg-black nx-break-words nx-rounded-md nx-border nx-py-0.5 nx-px-[.25em] nx-text-[.9em] dark:nx-border-white/10 dark:nx-bg-white/10" dir="ltr">n + 2</code> blocks) store the logs, and once full, the journal gets flushed, but more on that later.</p><h2 class="nx-not-prose subheading-h2">Conclusion<a href="#conclusion" id="conclusion" class="subheading-anchor" aria-label="Permalink for this section"></a></h2><p>So, this is how the journal works, and the &quot;more on that later&quot; parts will be explained in the next section that discusses the master node of mnemofs.</p></div>
<hr/>
<div class="nextra-cards nx-mt-4 nx-gap-4 nx-grid nx-not-prose" style="--rows:3"><a class="nextra-card nx-group nx-flex nx-flex-col nx-justify-start nx-overflow-hidden nx-rounded-lg nx-border nx-border-gray-200 nx-text-current nx-no-underline dark:nx-shadow-none hover:nx-shadow-gray-100 dark:hover:nx-shadow-none nx-shadow-gray-100 active:nx-shadow-sm active:nx-shadow-gray-200 nx-transition-all nx-duration-200 hover:nx-border-gray-300 nx-bg-transparent nx-shadow-sm dark:nx-border-neutral-800 hover:nx-bg-slate-50 hover:nx-shadow-md dark:hover:nx-border-neutral-700 dark:hover:nx-bg-neutral-900" href="/blogs/mnemofs/lru/"><span class="nx-flex nx-font-semibold nx-items-start nx-gap-2 nx-p-4 nx-text-gray-700 hover:nx-text-gray-900 dark:nx-text-neutral-200 dark:hover:nx-text-neutral-50 nx-flex nx-items-center">❰ <!-- -->Mnemofs LRU Cache</span></a><a class="nextra-card nx-group nx-flex nx-flex-col nx-justify-start nx-overflow-hidden nx-rounded-lg nx-border nx-border-gray-200 nx-text-current nx-no-underline dark:nx-shadow-none hover:nx-shadow-gray-100 dark:hover:nx-shadow-none nx-shadow-gray-100 active:nx-shadow-sm active:nx-shadow-gray-200 nx-transition-all nx-duration-200 hover:nx-border-gray-300 nx-bg-transparent nx-shadow-sm dark:nx-border-neutral-800 hover:nx-bg-slate-50 hover:nx-shadow-md dark:hover:nx-border-neutral-700 dark:hover:nx-bg-neutral-900" href="/blogs/mnemofs/mn/"><span class="nx-flex nx-font-semibold nx-items-start nx-gap-2 nx-p-4 nx-text-gray-700 hover:nx-text-gray-900 dark:nx-text-neutral-200 dark:hover:nx-text-neutral-50 nx-flex nx-items-center">❱ <!-- -->Mnemofs Master Node</span></a></div>
<br/>
<a class="nextra-card nx-group nx-flex nx-flex-col nx-justify-start nx-overflow-hidden nx-rounded-lg nx-border nx-border-gray-200 nx-text-current nx-no-underline dark:nx-shadow-none hover:nx-shadow-gray-100 dark:hover:nx-shadow-none nx-shadow-gray-100 active:nx-shadow-sm active:nx-shadow-gray-200 nx-transition-all nx-duration-200 hover:nx-border-gray-300 nx-bg-transparent nx-shadow-sm dark:nx-border-neutral-800 hover:nx-bg-slate-50 hover:nx-shadow-md dark:hover:nx-border-neutral-700 dark:hover:nx-bg-neutral-900" href="/blogs/"><span class="nx-flex nx-font-semibold nx-items-start nx-gap-2 nx-p-4 nx-text-gray-700 hover:nx-text-gray-900 dark:nx-text-neutral-200 dark:hover:nx-text-neutral-50 nx-flex nx-items-center">⌂ <!-- -->Home</span></a><p>MIT 2024 © resyfer.</p></article></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{}},"page":"/mnemofs/journal","query":{},"buildId":"2hS5wJtVXvVRna5Z6FRwt","assetPrefix":"/blogs","nextExport":true,"autoExport":true,"isFallback":false,"scriptLoader":[]}</script></body></html>